<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Operators - The Hydroflow Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="example_1_simplest.html"><strong aria-hidden="true">2.2.</strong> Simplest Example</a></li><li class="chapter-item expanded "><a href="example_2_simple.html"><strong aria-hidden="true">2.3.</strong> Simple Example</a></li><li class="chapter-item expanded "><a href="example_3_stream.html"><strong aria-hidden="true">2.4.</strong> A Example With Streaming Input</a></li><li class="chapter-item expanded "><a href="example_4_neighbors.html"><strong aria-hidden="true">2.5.</strong> Graph Neighbors</a></li><li class="chapter-item expanded "><a href="example_5_reachability.html"><strong aria-hidden="true">2.6.</strong> Graph Reachability</a></li><li class="chapter-item expanded "><a href="example_6_unreachability.html"><strong aria-hidden="true">2.7.</strong> Graph Un-Reachability</a></li><li class="chapter-item expanded "><a href="example_7_echo_server.html"><strong aria-hidden="true">2.8.</strong> Networked Services 1: EchoServer</a></li><li class="chapter-item expanded "><a href="example_8_chat_server.html"><strong aria-hidden="true">2.9.</strong> Networked Services 2: ChatServer</a></li></ol></li><li class="chapter-item expanded "><a href="surface_syntax.html"><strong aria-hidden="true">3.</strong> Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="surface_embedding.html"><strong aria-hidden="true">3.1.</strong> Rust Embedding</a></li><li class="chapter-item expanded "><a href="surface_flows.html"><strong aria-hidden="true">3.2.</strong> Flows</a></li><li class="chapter-item expanded "><a href="surface_data.html"><strong aria-hidden="true">3.3.</strong> Data Sources</a></li><li class="chapter-item expanded "><a href="surface_ops.gen.html" class="active"><strong aria-hidden="true">3.4.</strong> Operators</a></li><li class="chapter-item expanded "><a href="state.html"><strong aria-hidden="true">3.5.</strong> State and Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ecosystem.html"><strong aria-hidden="true">4.</strong> The Hydro Ecosystem</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">5.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="life_and_times.html"><strong aria-hidden="true">5.1.</strong> Life and Times of Hydroflow</a></li><li class="chapter-item expanded "><a href="stratification.html"><strong aria-hidden="true">5.2.</strong> Blocking Ops and Stratification</a></li><li class="chapter-item expanded "><a href="distributed_time.html"><strong aria-hidden="true">5.3.</strong> Distributed Time</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">5.4.</strong> Debugging Hydroflow</a></li><li class="chapter-item expanded "><a href="error_handling.html"><strong aria-hidden="true">5.5.</strong> Error Handling</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">6.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scheduling.html"><strong aria-hidden="true">6.1.</strong> Scheduling</a></li><li class="chapter-item expanded "><a href="handoffs.html"><strong aria-hidden="true">6.2.</strong> Handoffs</a></li><li class="chapter-item expanded "><a href="networking.html"><strong aria-hidden="true">6.3.</strong> Networking</a></li><li class="chapter-item expanded "><a href="in-out_trees.html"><strong aria-hidden="true">6.4.</strong> Subgraph In-Out Trees</a></li></ol></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">7.</strong> TODO</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">8.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hydroflow Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- GENERATED "hydroflow_macro/build.rs" -->
<h1 id="hydroflows-built-in-operators"><a class="header" href="#hydroflows-built-in-operators">Hydroflow's Built-in Operators</a></h1>
<p>In our previous examples we made use of some of Hydroflow's built-in operators.
Here we document each operators in more detail. Most of these operators
are based on the Rust equivalents for iterators; see the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Rust documentation</a>.</p>
<h2 id="anti_join"><a class="header" href="#anti_join"><code>anti_join</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; [&lt;input_port&gt;]anti_join() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Input port names: <code>pos</code> (streaming), <code>neg</code> (blocking)</p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/anti_join.rs" -->
<blockquote>
<p>2 input streams the first of type (K, T), the second of type K,
with output type (K, T)</p>
</blockquote>
<p>For a given tick, computes the anti-join of the items in the input
streams, returning items in the <code>pos</code> input that do not have matching keys
in the <code>neg</code> input.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print (&quot;elephant&quot;, 3)
source_iter(vec![(&quot;dog&quot;, 1), (&quot;cat&quot;, 2), (&quot;elephant&quot;, 3)]) -&gt; [pos]diff;
source_iter(vec![&quot;dog&quot;, &quot;cat&quot;, &quot;gorilla&quot;]) -&gt; [neg]diff;
diff = anti_join() -&gt; for_each(|v: (_, _)| println!(&quot;{}, {}&quot;, v.0, v.1));
// elephant 3
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="batch"><a class="header" href="#batch"><code>batch</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; batch(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/batch.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: The receive end of a tokio channel that signals when to release the batch downstream.</p>
</blockquote>
<p>Given a <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a>
created in Rust code, <code>batch</code>
is passed the receive end of the channel and when receiving any element
will pass through all received inputs to the output unchanged.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (tx, rx) = hydroflow::util::unbounded_channel::&lt;()&gt;();

    // Will print 0, 1, 2, 3, 4 each on a new line just once.
    let mut df = hydroflow::hydroflow_syntax! {
        repeat_iter(0..5) -&gt; batch(rx) -&gt; for_each(|x| { println!(&quot;{x}&quot;); });
    };

    tx.send(()).unwrap();

    df.run_available();
<span class="boring">}
</span></code></pre></pre>
<h2 id="cross_join"><a class="header" href="#cross_join"><code>cross_join</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; [&lt;input_port&gt;]cross_join() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Input port names: <code>0</code> (streaming), <code>1</code> (streaming)</p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/cross_join.rs" -->
<blockquote>
<p>2 input streams of type S and T, 1 output stream of type (S, T)</p>
</blockquote>
<p>Forms the cross-join (Cartesian product) of the items in the input streams, returning all
tupled pairs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print all 4 pairs of emotion and animal
source_iter(vec![&quot;happy&quot;, &quot;sad&quot;]) -&gt; [0]my_join;
source_iter(vec![&quot;dog&quot;, &quot;cat&quot;]) -&gt; [1]my_join;
my_join = cross_join() -&gt; for_each(|(v1, v2)| println!(&quot;({}, {})&quot;, v1, v2));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>cross_join</code> can also be provided with one or two generic lifetime persistence arguments
in the same was as <a href="#join"><code>join</code></a>, see <a href="#join"><code>join</code>'s documentation</a> for more info.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;&amp;str&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    my_join = cross_join::&lt;'tick&gt;();
    source_iter([&quot;hello&quot;, &quot;bye&quot;]) -&gt; [0]my_join;
    source_stream(input_recv) -&gt; [1]my_join;
    my_join -&gt; for_each(|(s, t)| println!(&quot;({}, {})&quot;, s, t));
};
input_send.send(&quot;oakland&quot;).unwrap();
flow.run_tick();
input_send.send(&quot;san francisco&quot;).unwrap();
flow.run_tick();
<span class="boring">}
</span></code></pre></pre>
<p>Prints only <code>&quot;(hello, oakland)&quot;</code> and <code>&quot;(bye, oakland)&quot;</code>. The <code>source_iter</code> is only included in
the first tick, then forgotten.</p>
<h2 id="demux"><a class="header" href="#demux"><code>demux</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; demux(A)[&lt;output_port&gt;] -&gt;</code></td><td><span title="at least 2">at least 2</span></td><td>Streaming</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Output port names: Variadic, as specified in arguments.</p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/demux.rs" -->
<blockquote>
<p>Arguments: A Rust closure, the first argument is a received item and the
second argument is a variadic <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/macro.var_args.html"><code>var_args!</code> tuple list</a>
where each item name is an output port.</p>
</blockquote>
<p>Takes the input stream and allows the user to determine what elemnt(s) to
deliver to any number of output streams.</p>
<blockquote>
<p>Note: Downstream operators may need explicit type annotations.</p>
</blockquote>
<blockquote>
<p>Note: The <a href="https://hydro-project.github.io/hydroflow/doc/pusherator/trait.Pusherator.html"><code>Pusherator</code></a>
trait is automatically imported to enable the <a href="https://hydro-project.github.io/hydroflow/doc/pusherator/trait.Pusherator.html#tymethod.give"><code>.give(...)</code> method</a>.</p>
</blockquote>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>my_demux = source_iter(1..=100) -&gt; demux(|v, var_args!(fzbz, fizz, buzz, vals)|
    match (v % 3, v % 5) {
        (0, 0) =&gt; fzbz.give(v),
        (0, _) =&gt; fizz.give(v),
        (_, 0) =&gt; buzz.give(v),
        (_, _) =&gt; vals.give(v),
    }
);
my_demux[fzbz] -&gt; for_each(|v| println!(&quot;{}: fizzbuzz&quot;, v));
my_demux[fizz] -&gt; for_each(|v| println!(&quot;{}: fizz&quot;, v));
my_demux[buzz] -&gt; for_each(|v| println!(&quot;{}: buzz&quot;, v));
my_demux[vals] -&gt; for_each(|v| println!(&quot;{}&quot;, v));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="dest_sink"><a class="header" href="#dest_sink"><code>dest_sink</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; dest_sink(A)</code></td><td><span title="exactly 0">exactly 0</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/dest_sink.rs" -->
<blockquote>
<p>Arguments: An <a href="https://docs.rs/futures/latest/futures/sink/trait.Sink.html">async <code>Sink</code></a>.</p>
</blockquote>
<p>Consumes items by sending them to an <a href="https://docs.rs/futures/latest/futures/sink/trait.Sink.html">async <code>Sink</code></a>.
A <code>Sink</code> is a thing into which values can be sent, asynchronously. For example, sending items
into a bounded channel.</p>
<p>Note this operator must be used within a Tokio runtime.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[tokio::main(flavor = &quot;current_thread&quot;)]
</span><span class="boring">async fn main() {
</span>// In this example we use a _bounded_ channel for our `Sink`. This is for demonstration only,
// instead you should use [`hydroflow::util::unbounded_channel`]. A bounded channel results in
// `Hydroflow` buffering items internally instead of within the channel. (We can't use
// unbounded here since unbounded channels are synchonous to write to and therefore not
// `Sink`s.)
let (send, recv) = tokio::sync::mpsc::channel::&lt;usize&gt;(5);
// `PollSender` adapts the send half of the bounded channel into a `Sink`.
let send = tokio_util::sync::PollSender::new(send);

let mut flow = hydroflow::hydroflow_syntax! {
    source_iter(0..10) -&gt; dest_sink(send);
};
// Call `run_async()` to allow async events to propegate, run for one second.
tokio::time::timeout(std::time::Duration::from_secs(1), flow.run_async())
    .await
    .expect_err(&quot;Expected time out&quot;);

let mut recv = tokio_stream::wrappers::ReceiverStream::new(recv);
// Only 5 elements received due to buffer size.
// (Note that if we were using a multi-threaded executor instead of `current_thread` it would
// be possible for more items to be added as they're removed, resulting in &gt;5 collected.)
let out: Vec&lt;_&gt; = hydroflow::util::ready_iter(&amp;mut recv).collect();
assert_eq!(&amp;[0, 1, 2, 3, 4], &amp;*out);
<span class="boring">}
</span></code></pre></pre>
<p><code>Sink</code> is different from <a href="https://docs.rs/futures/latest/futures/io/trait.AsyncWrite.html"><code>AsyncWrite</code></a>.
Instead of discrete values we send arbitrary streams of bytes into an <code>AsyncWrite</code> value. For
example, writings a stream of bytes to a file, a socket, or stdout.</p>
<p>To handle those situations we can use a codec from <a href="crate::tokio_util::codec"><code>tokio_util::codec</code></a>.
These specify ways in which the byte stream is broken into individual items, such as with
newlines or with length delineation.</p>
<p>If we only want to write a stream of bytes without delineation we can use the <a href="crate::tokio_util::codec::BytesCodec"><code>BytesCodec</code></a>.</p>
<p>In this example we use a <a href="crate::tokio::io::duplex"><code>duplex</code></a> as our <code>AsyncWrite</code> with a
<code>BytesCodec</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span>use bytes::Bytes;
use tokio::io::AsyncReadExt;

// Like a channel, but for a stream of bytes instead of discrete objects.
let (asyncwrite, mut asyncread) = tokio::io::duplex(256);
// Now instead handle discrete byte strings by length-encoding them.
let sink = tokio_util::codec::FramedWrite::new(asyncwrite, tokio_util::codec::BytesCodec::new());

let mut flow = hydroflow::hydroflow_syntax! {
    source_iter([
        Bytes::from_static(b&quot;hello&quot;),
        Bytes::from_static(b&quot;world&quot;),
    ]) -&gt; dest_sink(sink);
};
tokio::time::timeout(std::time::Duration::from_secs(1), flow.run_async())
    .await
    .expect_err(&quot;Expected time out&quot;);

let mut buf = Vec::&lt;u8&gt;::new();
asyncread.read_buf(&amp;mut buf).await.unwrap();
assert_eq!(b&quot;helloworld&quot;, &amp;*buf);
<span class="boring">}
</span></code></pre></pre>
<h2 id="dest_sink_serde"><a class="header" href="#dest_sink_serde"><code>dest_sink_serde</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; dest_sink_serde(A)</code></td><td><span title="exactly 0">exactly 0</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/dest_sink_serde.rs" -->
<blockquote>
<p>Arguments: A <a href="https://docs.rs/futures/latest/futures/sink/trait.Sink.html">serializing async <code>Sink</code></a>.</p>
</blockquote>
<p>Consumes (payload, addr) pairs by serializing the payload and sending the resulting pair to an <a href="https://docs.rs/futures/latest/futures/sink/trait.Sink.html">async <code>Sink</code></a>.</p>
<p>Note this operator must be used within a Tokio runtime.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn serde_out() {
    let addr = hydroflow::util::ipv4_resolve(&quot;localhost:9000&quot;.into()).unwrap();
    let (outbound, inbound, _) = hydroflow::util::bind_udp_bytes(addr).await;
    let remote = hydroflow::util::ipv4_resolve(&quot;localhost:9001&quot;.into()).unwrap();
    let mut flow = hydroflow::hydroflow_syntax! {
        source_iter(vec![(&quot;hello&quot;.to_string(), 1), (&quot;world&quot;.to_string(), 2)])
            -&gt; map (|m| (m, remote)) -&gt; dest_sink_serde(outbound);
    };
    flow.run_available();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="difference"><a class="header" href="#difference"><code>difference</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; [&lt;input_port&gt;]difference() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Input port names: <code>pos</code> (streaming), <code>neg</code> (blocking)</p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/difference.rs" -->
<blockquote>
<p>2 input streams of the same type T, 1 output stream of type T</p>
</blockquote>
<p>For a given tick, forms the set difference of the items in the input
streams, returning items in the <code>pos</code> input that are not found in the
<code>neg</code> input.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print &quot;elephant&quot;
source_iter(vec![&quot;dog&quot;, &quot;cat&quot;, &quot;elephant&quot;]) -&gt; [pos]diff;
source_iter(vec![&quot;dog&quot;, &quot;cat&quot;, &quot;gorilla&quot;]) -&gt; [neg]diff;
diff = difference() -&gt; for_each(|v| println!(&quot;{}&quot;, v));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="filter"><a class="header" href="#filter"><code>filter</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; filter(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/filter.rs" -->
<p>Filter outputs a subsequence of the items it receives at its input, according to a
Rust boolean closure passed in as an argument.</p>
<p>The closure receives a reference <code>&amp;T</code> rather than an owned value <code>T</code> because filtering does
not modify or take ownership of the values. If you need to modify the values while filtering
use <a href="#filter_map"><code>filter_map</code></a> instead.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; filter(|x| x.starts_with('w'))
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="filter_map"><a class="header" href="#filter_map"><code>filter_map</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; filter_map(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/filter_map.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<p>An operator that both filters and maps. It yields only the items for which the supplied closure returns <code>Some(value)</code>.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter(vec![&quot;1&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;2&quot;]) -&gt; filter_map(|s| s.parse().ok())
    -&gt; for_each(|x: usize| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="flat_map"><a class="header" href="#flat_map"><code>flat_map</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; flat_map(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/flat_map.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: A Rust closure that handles an iterator</p>
</blockquote>
<p>For each item <code>i</code> passed in, treat <code>i</code> as an iterator and map the closure to that
iterator to produce items one by one. The type of the input items must be iterable.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print out each character of each word on a separate line
source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; flat_map(|x| x.chars())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="flatten"><a class="header" href="#flatten"><code>flatten</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; flatten() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/flatten.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<p>For each item <code>i</code> passed in, treat <code>i</code> as an iterator and produce its items one by one.
The type of the input items must be iterable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print the numbers 1-6 without any nesting
source_iter(vec![[1, 2], [3, 4], [5, 6]]) -&gt; flatten()
-&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="fold"><a class="header" href="#fold"><code>fold</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; fold(A, B) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/fold.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: an initial value, and a closure which itself takes two arguments:
an 'accumulator', and an element. The closure returns the value that the accumulator should have for the next iteration.</p>
</blockquote>
<p>Akin to Rust's built-in fold operator. Folds every element into an accumulator by applying a closure,
returning the final result.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<p><code>fold</code> can also be provided with one generic lifetime persistence argument, either
<code>'tick</code> or <code>'static</code>, to specify how data persists. With <code>'tick</code>, values will only be collected
within the same tick. With <code>'static</code>, values will be remembered across ticks and will be
aggregated with pairs arriving in later ticks. When not explicitly specified persistence
defaults to <code>'static</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print `Reassembled vector [1,2,3,4,5]`
source_iter([1,2,3,4,5])
    -&gt; fold::&lt;'tick&gt;(Vec::new(), |mut accum, elem| {
        accum.push(elem);
        accum
    })
    -&gt; for_each(|e| println!(&quot;Ressembled vector {:?}&quot;, e));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="for_each"><a class="header" href="#for_each"><code>for_each</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; for_each(A)</code></td><td><span title="exactly 0">exactly 0</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/for_each.rs" -->
<blockquote>
<p>1 input stream, 0 output streams</p>
</blockquote>
<blockquote>
<p>Arguments: a Rust closure</p>
</blockquote>
<p>Iterates through a stream passing each element to the closure in the
argument.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>    source_iter(vec![&quot;Hello&quot;, &quot;World&quot;])
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="group_by"><a class="header" href="#group_by"><code>group_by</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; group_by(A, B) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/group_by.rs" -->
<blockquote>
<p>1 input stream of type (K,V1), 1 output stream of type (K,V2).
The output will have one tuple for each distinct K, with an accumulated value of type V2.</p>
</blockquote>
<blockquote>
<p>Arguments: two Rust closures. The first generates an initial value per group. The second
itself takes two arguments: an 'accumulator', and an element. The second closure returns the
value that the accumulator should have for the next iteration.</p>
</blockquote>
<p>A special case of <code>fold</code>, in the spirit of SQL's GROUP BY and aggregation constructs. The input
is partitioned into groups by the first field, and for each group the values in the second
field are accumulated via the closures in the arguments.</p>
<blockquote>
<p>Note: The closures have access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<p><code>group_by</code> can also be provided with one generic lifetime persistence argument, either
<code>'tick</code> or <code>'static</code>, to specify how data persists. With <code>'tick</code>, values will only be collected
within the same tick. With <code>'static</code>, values will be remembered across ticks and will be
aggregated with pairs arriving in later ticks. When not explicitly specified persistence
defaults to <code>'static</code>.</p>
<p><code>group_by</code> can also be provided with two type arguments, the key and value type. This is
required when using <code>'static</code> persistence if the compiler cannot infer the types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter([(&quot;toy&quot;, 1), (&quot;toy&quot;, 2), (&quot;shoe&quot;, 11), (&quot;shoe&quot;, 35), (&quot;haberdashery&quot;, 7)])
    -&gt; group_by(|| 0, |old: &amp;mut u32, val: u32| *old += val)
    -&gt; for_each(|(k, v)| println!(&quot;Total for group {} is {}&quot;, k, v));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Example using <code>'tick</code> persistence:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;(&amp;str, &amp;str)&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    source_stream(input_recv)
        -&gt; group_by::&lt;'tick, &amp;str, String&gt;(String::new, |old: &amp;mut _, val| {
            *old += val;
            *old += &quot;, &quot;;
        })
        -&gt; for_each(|(k, v)| println!(&quot;({:?}, {:?})&quot;, k, v));
};

input_send.send((&quot;hello&quot;, &quot;oakland&quot;)).unwrap();
input_send.send((&quot;hello&quot;, &quot;berkeley&quot;)).unwrap();
input_send.send((&quot;hello&quot;, &quot;san francisco&quot;)).unwrap();
flow.run_available();
// (&quot;hello&quot;, &quot;oakland, berkeley, san francisco, &quot;)

input_send.send((&quot;hello&quot;, &quot;palo alto&quot;)).unwrap();
flow.run_available();
// (&quot;hello&quot;, &quot;palo alto, &quot;)
<span class="boring">}
</span></code></pre></pre>
<h2 id="identity"><a class="header" href="#identity"><code>identity</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; identity() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/identity.rs" -->
<blockquote>
<p>1 input stream of type T, 1 output stream of type T</p>
</blockquote>
<p>For each item passed in, pass it out without any change.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print &quot;hello&quot; and &quot;world&quot; on separate lines (in either order)
source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; identity()
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>You can also supply a type parameter <code>identity::&lt;MyType&gt;()</code> to specify what items flow thru the
the pipeline. This can be useful for helping the compiler infer types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// Use type parameter to ensure items are `i32`s.
source_iter(0..10) -&gt; identity::&lt;i32&gt;() -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="initialize"><a class="header" href="#initialize"><code>initialize</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>initialize() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/initialize.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: None.</p>
</blockquote>
<p>Emits a single unit <code>()</code> at the start of the first tick.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>initialize() -&gt; for_each(|()| println!(&quot;This only runs one time!&quot;));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="inspect"><a class="header" href="#inspect"><code>inspect</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; inspect(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/inspect.rs" -->
<blockquote>
<p>Arguments: A single closure <code>FnMut(&amp;Item)</code>.</p>
</blockquote>
<p>An operator which allows you to &quot;inspect&quot; each element of a stream without
modifying it. The closure is called on a reference to each item. This is
mainly useful for debugging as in the example below, and it is generally an
anti-pattern to provide a closure with side effects.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter([1, 2, 3, 4]) -&gt; inspect(|&amp;x| println!(&quot;{}&quot;, x)) -&gt; null();
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="join"><a class="header" href="#join"><code>join</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; [&lt;input_port&gt;]join() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Input port names: <code>0</code> (streaming), <code>1</code> (streaming)</p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/join.rs" -->
<blockquote>
<p>2 input streams of type &lt;(K, V1)&gt; and &lt;(K, V2)&gt;, 1 output stream of type &lt;(K, (V1, V2))&gt;</p>
</blockquote>
<p>Forms the equijoin of the tuples in the input streams by their first (key) attribute. Note that the result nests the 2nd input field (values) into a tuple in the 2nd output field.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print `(hello, (world, cleveland))`
source_iter(vec![(&quot;hello&quot;, &quot;world&quot;), (&quot;stay&quot;, &quot;gold&quot;)]) -&gt; [0]my_join;
source_iter(vec![(&quot;hello&quot;, &quot;cleveland&quot;)]) -&gt; [1]my_join;
my_join = join() -&gt; for_each(|(k, (v1, v2))| println!(&quot;({}, ({}, {}))&quot;, k, v1, v2));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>join</code> can also be provided with one or two generic lifetime persistence arguments, either
<code>'tick</code> or <code>'static</code>, to specify how join data persists. With <code>'tick</code>, pairs will only be
joined with corresponding pairs within the same tick. With <code>'static</code>, pairs will be remembered
across ticks and will be joined with pairs arriving in later ticks. When not explicitly
specified persistence defaults to `static.</p>
<p>When two persistence arguments are supplied the first maps to port <code>0</code> and the second maps to
port <code>1</code>.
When a single persistence argument is supplied, it is applied to both input ports.
When no persistence arguments are applied it defaults to <code>'static</code> for both.</p>
<p>The syntax is as follows:</p>
<pre><code class="language-hydroflow ignore">join(); // Or
join::&lt;'static&gt;();

join::&lt;'tick&gt;();

join::&lt;'static, 'tick&gt;();

join::&lt;'tick, 'static&gt;();
// etc.
</code></pre>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;(&amp;str, &amp;str)&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    source_iter([(&quot;hello&quot;, &quot;world&quot;)]) -&gt; [0]my_join;
    source_stream(input_recv) -&gt; [1]my_join;
    my_join = join::&lt;'tick&gt;() -&gt; for_each(|(k, (v1, v2))| println!(&quot;({}, ({}, {}))&quot;, k, v1, v2));
};
input_send.send((&quot;hello&quot;, &quot;oakland&quot;)).unwrap();
flow.run_tick();
input_send.send((&quot;hello&quot;, &quot;san francisco&quot;)).unwrap();
flow.run_tick();
<span class="boring">}
</span></code></pre></pre>
<p>Prints out <code>&quot;(hello, (world, oakland))&quot;</code> since <code>source_iter([(&quot;hello&quot;, &quot;world&quot;)])</code> is only
included in the first tick, then forgotten.</p>
<hr />
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;(&amp;str, &amp;str)&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    source_iter([(&quot;hello&quot;, &quot;world&quot;)]) -&gt; [0]my_join;
    source_stream(input_recv) -&gt; [1]my_join;
    my_join = join::&lt;'static&gt;() -&gt; for_each(|(k, (v1, v2))| println!(&quot;({}, ({}, {}))&quot;, k, v1, v2));
};
input_send.send((&quot;hello&quot;, &quot;oakland&quot;)).unwrap();
flow.run_tick();
input_send.send((&quot;hello&quot;, &quot;san francisco&quot;)).unwrap();
flow.run_tick();
<span class="boring">}
</span></code></pre></pre>
<p>Prints out <code>&quot;(hello, (world, oakland))&quot;</code> and <code>&quot;(hello, (world, san francisco))&quot;</code> since the
inputs are peristed across ticks.</p>
<h2 id="map"><a class="header" href="#map"><code>map</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; map(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/map.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: A Rust closure
For each item passed in, apply the closure to generate an item to emit.</p>
</blockquote>
<p>If you do not want to modify the item stream and instead only want to view
each item use the <a href="#inspect"><code>inspect</code></a> operator instead.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; map(|x| x.to_uppercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="merge"><a class="header" href="#merge"><code>merge</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="at least 0">at least 2</span></td><td><code>-&gt; [&lt;input_port&gt;]merge() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/merge.rs" -->
<blockquote>
<p><em>n</em> input streams of the same type, 1 output stream of the same type</p>
</blockquote>
<p>Merges an arbitrary number of input streams into a single stream. Each input sequence is a subsequence of the output, but no guarantee is given on how the inputs are interleaved.</p>
<p>Since <code>merge</code> has multiple input streams, it needs to be assigned to
a variable to reference its multiple input ports across statements.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; my_merge;
source_iter(vec![&quot;stay&quot;, &quot;gold&quot;]) -&gt; my_merge;
source_iter(vec![&quot;don\'t&quot;, &quot;give&quot;, &quot;up&quot;]) -&gt; my_merge;
my_merge = merge() -&gt; map(|x| x.to_uppercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="next_stratum"><a class="header" href="#next_stratum"><code>next_stratum</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; next_stratum() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/next_stratum.rs" -->
<p>Delays all elements which pass through to the next stratum (in the same
tick).</p>
<h2 id="next_tick"><a class="header" href="#next_tick"><code>next_tick</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; next_tick() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/next_tick.rs" -->
<p>Delays all elements which pass through to the next tick. In short,
execution of a hydroflow graph runs as a sequence of distinct &quot;ticks&quot;.
Non-monotonic operators compute their output in terms of each tick so
execution doesn't have to block, and it is up to the user to coordinate
data between tick executions to achieve the desired result.</p>
<p>An tick may be divided into multiple <em>strata</em>, see the <a href="#next_stratum"><code>next_stratum()</code></a>
operator.</p>
<p>In the example below <code>next_tick()</code> is used alongside <code>difference()</code> to
ignore any items in the current tick that already appeared in the previous
tick.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Outputs 1 2 3 4 5 6 (on separate lines).
let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;usize&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    inp = source_stream(input_recv) -&gt; tee();
    diff = difference() -&gt; for_each(|x| println!(&quot;{}&quot;, x));
    inp -&gt; [pos]diff;
    inp -&gt; next_tick() -&gt; [neg]diff;
};

for x in [1, 2, 3, 4] {
    input_send.send(x).unwrap();
}
flow.run_tick();

for x in [3, 4, 5, 6] {
    input_send.send(x).unwrap();
}
flow.run_tick();
<span class="boring">}
</span></code></pre></pre>
<h2 id="null"><a class="header" href="#null"><code>null</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="at least 0 and at most 1">at least 0 and at most 1</span></td><td><code>null()</code></td><td><span title="at least 0 and at most 1">at least 0 and at most 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/null.rs" -->
<blockquote>
<p>unbounded number of input streams of any type, unbounded number of output streams of any type.</p>
</blockquote>
<p>As a source, generates nothing. As a sink, absorbs anything with no effect.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print `1, 2, 3, 4, 5, 6, a, b, c` across 9 lines
null() -&gt; for_each(|_: ()| panic!());
source_iter([1,2,3]) -&gt; map(|i| println!(&quot;{}&quot;, i)) -&gt; null();
null_src = null();
null_sink = null();
null_src[0] -&gt; for_each(|_: ()| panic!());
// note: use `for_each()` (or `inspect()`) instead of this:
source_iter([4,5,6]) -&gt; map(|i| println!(&quot;{}&quot;, i)) -&gt; [0]null_sink;
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="persist"><a class="header" href="#persist"><code>persist</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; persist() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/persist.rs" -->
<p>Stores each item as it passes through, and replays all item every tick.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// Normally `source_iter(...)` only emits once, but with `persist()` will replay the `&quot;hello&quot;`
// on every tick. This is equivalent to `repeat_iter([&quot;hello&quot;])`.
source_iter([&quot;hello&quot;])
    -&gt; persist()
    -&gt; for_each(|item| println!(&quot;{}: {}&quot;, context.current_tick(), item));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>persist()</code> can be used to introduce statefulness into stateless pipelines. For example this
join only stores data for single <code>'tick</code>. The <code>persist()</code> operator introduces statefulness
across ticks. This can be useful for optimization transformations within the hydroflow
compiler.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;(&amp;str, &amp;str)&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    repeat_iter([(&quot;hello&quot;, &quot;world&quot;)]) -&gt; [0]my_join;
    source_stream(input_recv) -&gt; persist() -&gt; [1]my_join;
    my_join = join::&lt;'tick&gt;() -&gt; for_each(|(k, (v1, v2))| println!(&quot;({}, ({}, {}))&quot;, k, v1, v2));
};
input_send.send((&quot;hello&quot;, &quot;oakland&quot;)).unwrap();
flow.run_tick();
input_send.send((&quot;hello&quot;, &quot;san francisco&quot;)).unwrap();
flow.run_tick();
// (hello, (world, oakland))
// (hello, (world, oakland))
// (hello, (world, san francisco))
<span class="boring">}
</span></code></pre></pre>
<h2 id="reduce"><a class="header" href="#reduce"><code>reduce</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; reduce(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/reduce.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: a closure which itself takes two arguments:
an ‘accumulator’, and an element. The closure returns the value that the accumulator should have for the next iteration.</p>
</blockquote>
<p>Akin to Rust's built-in reduce operator. Folds every element into an accumulator by applying a closure,
returning the final result.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print 120 (i.e., 1*2*3*4*5)
source_iter([1,2,3,4,5])
    -&gt; reduce(|mut accum, elem| {
        accum *= elem;
        accum
    })
    -&gt; for_each(|e| println!(&quot;{}&quot;, e));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="repeat_iter"><a class="header" href="#repeat_iter"><code>repeat_iter</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>repeat_iter(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/repeat_iter.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: An iterable Rust object.
Similar to <code>source_iter</code>, but delivers all elements from the iterable object
on every tick (where <code>source_iter</code> only delivers on the first tick).</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>    repeat_iter(vec![&quot;Hello&quot;, &quot;World&quot;])
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="sort"><a class="header" href="#sort"><code>sort</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; sort() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/sort.rs" -->
<p>Takes a stream as input and produces a sorted version of the stream as output.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print 1, 2, 3 (in order)
source_iter(vec![2, 3, 1])
    -&gt; sort()
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>sort</code> can also be provided with one generic lifetime persistence argument, either
<code>'tick</code> or <code>'static</code>, to specify how data persists. The default is <code>'tick</code>. With <code>'tick</code> only
the values will only be collected within a single tick will be sorted and emitted. With
<code>'static</code>, values will be remembered across ticks and will be repeatedly emitted each tick (in
order).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;usize&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    source_stream(input_recv)
        -&gt; sort::&lt;'static&gt;()
        -&gt; for_each(|n| println!(&quot;{}&quot;, n));
};

input_send.send(6).unwrap();
input_send.send(3).unwrap();
input_send.send(4).unwrap();
flow.run_available();
// 3, 4, 6

input_send.send(1).unwrap();
input_send.send(7).unwrap();
flow.run_available();
// 1, 3, 4, 6, 7
<span class="boring">}
</span></code></pre></pre>
<h2 id="sort_by"><a class="header" href="#sort_by"><code>sort_by</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; sort_by(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/sort_by.rs" -->
<p>Takes a stream as input and produces a version of the stream as output
sorted according to the key extracted by the closure.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print (1, 'z'), (2, 'y'), (3, 'x') (in order)
source_iter(vec![(2, 'y'), (3, 'x'), (1, 'z')])
    -&gt; sort_by(|(k, _v)| k)
    -&gt; for_each(|x| println!(&quot;{:?}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="source_interval"><a class="header" href="#source_interval"><code>source_interval</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_interval(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_interval.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: A <a href="https://doc.rust-lang.org/stable/std/time/struct.Duration.html"><code>Duration</code></a> for this interval.</p>
</blockquote>
<p>Emits <a href="https://docs.rs/tokio/1/tokio/time/struct.Instant.html">Tokio time <code>Instant</code>s</a> on a
repeated interval. The first tick completes imediately. Missed ticks will be scheduled as soon
as possible, and the <code>Instant</code> will be the missed time, not the late time.</p>
<p>Note that this requires the hydroflow instance be run within a <a href="https://docs.rs/tokio/1/tokio/runtime/struct.Runtime.html">Tokio <code>Runtime</code></a>.
The easiest way to do this is with a <a href="https://docs.rs/tokio/1/tokio/attr.main.html"><code>#[tokio::main]</code></a>
annotation on <code>async fn main() { ... }</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Duration;

use hydroflow::hydroflow_syntax;

#[tokio::main]
async fn main() {
    let mut hf = hydroflow_syntax! {
        source_interval(Duration::from_secs(1))
            -&gt; for_each(|time| println!(&quot;This runs every second: {:?}&quot;, time));
    };

    // Will print 4 times (fencepost counting).
    tokio::time::timeout(Duration::from_secs_f32(3.5), hf.run_async())
        .await
        .expect_err(&quot;Expected time out&quot;);

    // Example output:
    // This runs every second: Instant { t: 27471.704813s }
    // This runs every second: Instant { t: 27472.704813s }
    // This runs every second: Instant { t: 27473.704813s }
    // This runs every second: Instant { t: 27474.704813s }
}
</code></pre></pre>
<h2 id="source_iter"><a class="header" href="#source_iter"><code>source_iter</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_iter(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_iter.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: An iterable Rust object.
Takes the iterable object and delivers its elements downstream
one by one.</p>
</blockquote>
<p>Note that all elements are emitted during the first tick.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>    source_iter(vec![&quot;Hello&quot;, &quot;World&quot;])
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="source_json"><a class="header" href="#source_json"><code>source_json</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_json(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_json.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: An <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a><code>&lt;</code><a href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html"><code>Path</code></a><code>&gt;</code>
for a file to read as json. This will emit the parsed value one time.</p>
</blockquote>
<p><code>source_json</code> may take one generic type argument, the type of the value to be parsed, which must implement <a href="https://docs.rs/serde/latest/serde/de/trait.Deserialize.html"><code>Deserialize</code></a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_json(&quot;example.json&quot;) -&gt; for_each(|json: hydroflow::serde_json::Value| println!(&quot;{:#?}&quot;, json));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="source_stdin"><a class="header" href="#source_stdin"><code>source_stdin</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_stdin() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_stdin.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: port number</p>
</blockquote>
<p><code>source_stdin</code> receives a Stream of lines from stdin
and emits each of the elements it receives downstream.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut flow = hydroflow::hydroflow_syntax! {
    source_stdin() -&gt; map(|x| x.unwrap().to_uppercase())
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
};
flow.run_async();
<span class="boring">}
</span></code></pre></pre>
<h2 id="source_stream"><a class="header" href="#source_stream"><code>source_stream</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_stream(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_stream.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: The receive end of a tokio channel</p>
</blockquote>
<p>Given a <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a>
created in Rust code, <code>source_stream</code>
is passed the receive endpoint of the channel and emits each of the
elements it receives downstream.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;&amp;str&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    source_stream(input_recv) -&gt; map(|x| x.to_uppercase())
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
};
input_send.send(&quot;Hello&quot;).unwrap();
input_send.send(&quot;World&quot;).unwrap();
flow.run_available();
<span class="boring">}
</span></code></pre></pre>
<h2 id="source_stream_serde"><a class="header" href="#source_stream_serde"><code>source_stream_serde</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_stream_serde(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_stream_serde.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a></p>
</blockquote>
<p>Given a <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a>
of (serialized payload, addr) pairs, deserializes the payload and emits each of the
elements it receives downstream.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn serde_in() {
    let addr = hydroflow::util::ipv4_resolve(&quot;localhost:9000&quot;.into()).unwrap();
    let (outbound, inbound, _) = hydroflow::util::bind_udp_bytes(addr).await;
    let mut flow = hydroflow::hydroflow_syntax! {
        source_stream_serde(inbound) -&gt; map(|(x, a): (String, std::net::SocketAddr)| x.to_uppercase())
            -&gt; for_each(|x| println!(&quot;{}&quot;, x));
    };
    flow.run_available();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="tee"><a class="header" href="#tee"><code>tee</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; tee()[&lt;output_port&gt;] -&gt;</code></td><td><span title="at least 0">at least 2</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/tee.rs" -->
<blockquote>
<p>1 input stream, <em>n</em> output streams</p>
</blockquote>
<p>Takes the input stream and delivers a copy of each item to each output.</p>
<blockquote>
<p>Note: Downstream operators may need explicit type annotations.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>my_tee = source_iter(vec![&quot;Hello&quot;, &quot;World&quot;]) -&gt; tee();
my_tee -&gt; map(|x: &amp;str| x.to_uppercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
my_tee -&gt; map(|x: &amp;str| x.to_lowercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
my_tee -&gt; for_each(|x: &amp;str| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="unique"><a class="header" href="#unique"><code>unique</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; unique() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/unique.rs" -->
<p>Takes one stream as input and filters out any duplicate occurrences. The output
contains all unique values from the input.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print 1, 2, 3 (in any order)
source_iter(vec![1, 1, 2, 3, 2, 1, 3])
    -&gt; unique()
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>unique</code> can also be provided with one generic lifetime persistence argument, either
<code>'tick</code> or <code>'static</code>, to specify how data persists. The default is <code>'static</code>.
With <code>'tick</code>, uniqueness is only considered within the current tick, so across multiple ticks
duplicate values may be emitted.
With <code>'static</code>, values will be remembered across ticks and no duplicates will ever be emitted.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;usize&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    source_stream(input_recv)
        -&gt; unique::&lt;'tick&gt;()
        -&gt; for_each(|n| println!(&quot;{}&quot;, n));
};

input_send.send(3).unwrap();
input_send.send(3).unwrap();
input_send.send(4).unwrap();
input_send.send(3).unwrap();
flow.run_available();
// 3, 4

input_send.send(3).unwrap();
input_send.send(5).unwrap();
flow.run_available();
// 3, 5
// Note: 3 is emitted again.
<span class="boring">}
</span></code></pre></pre>
<h2 id="unzip"><a class="header" href="#unzip"><code>unzip</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; unzip()[&lt;output_port&gt;] -&gt;</code></td><td><span title="exactly 2">exactly 2</span></td><td>Streaming</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Output port names: <code>0</code>, <code>1</code></p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/unzip.rs" -->
<blockquote>
<p>1 input stream of pair tuples <code>(A, B)</code>, 2 output streams</p>
</blockquote>
<p>Takes the input stream of pairs and unzips each one, delivers each item to
its corresponding side.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>my_unzip = source_iter(vec![(&quot;Hello&quot;, &quot;Foo&quot;), (&quot;World&quot;, &quot;Bar&quot;)]) -&gt; unzip();
my_unzip[0] -&gt; for_each(|x| println!(&quot;0: {}&quot;, x)); // Hello World
my_unzip[1] -&gt; for_each(|x| println!(&quot;1: {}&quot;, x)); // Foo Bar
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="surface_data.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="state.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="surface_data.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="state.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
    </body>
</html>
