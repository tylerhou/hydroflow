<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Hydroflow Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="example_1_simplest.html"><strong aria-hidden="true">2.2.</strong> Simplest Example</a></li><li class="chapter-item expanded "><a href="example_2_simple.html"><strong aria-hidden="true">2.3.</strong> Simple Example</a></li><li class="chapter-item expanded "><a href="example_3_stream.html"><strong aria-hidden="true">2.4.</strong> A Example With Streaming Input</a></li><li class="chapter-item expanded "><a href="example_4_neighbors.html"><strong aria-hidden="true">2.5.</strong> Graph Neighbors</a></li><li class="chapter-item expanded "><a href="example_5_reachability.html"><strong aria-hidden="true">2.6.</strong> Graph Reachability</a></li><li class="chapter-item expanded "><a href="example_6_unreachability.html"><strong aria-hidden="true">2.7.</strong> Graph Un-Reachability</a></li><li class="chapter-item expanded "><a href="example_7_echo_server.html"><strong aria-hidden="true">2.8.</strong> Networked Services 1: EchoServer</a></li><li class="chapter-item expanded "><a href="example_8_chat_server.html"><strong aria-hidden="true">2.9.</strong> Networked Services 2: ChatServer</a></li></ol></li><li class="chapter-item expanded "><a href="surface_syntax.html"><strong aria-hidden="true">3.</strong> Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="surface_embedding.html"><strong aria-hidden="true">3.1.</strong> Rust Embedding</a></li><li class="chapter-item expanded "><a href="surface_flows.html"><strong aria-hidden="true">3.2.</strong> Flows</a></li><li class="chapter-item expanded "><a href="surface_data.html"><strong aria-hidden="true">3.3.</strong> Data Sources</a></li><li class="chapter-item expanded "><a href="surface_ops.gen.html"><strong aria-hidden="true">3.4.</strong> Operators</a></li><li class="chapter-item expanded "><a href="state.html"><strong aria-hidden="true">3.5.</strong> State and Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ecosystem.html"><strong aria-hidden="true">4.</strong> The Hydro Ecosystem</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">5.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="life_and_times.html"><strong aria-hidden="true">5.1.</strong> Life and Times of Hydroflow</a></li><li class="chapter-item expanded "><a href="stratification.html"><strong aria-hidden="true">5.2.</strong> Blocking Ops and Stratification</a></li><li class="chapter-item expanded "><a href="distributed_time.html"><strong aria-hidden="true">5.3.</strong> Distributed Time</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">5.4.</strong> Debugging Hydroflow</a></li><li class="chapter-item expanded "><a href="error_handling.html"><strong aria-hidden="true">5.5.</strong> Error Handling</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">6.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scheduling.html"><strong aria-hidden="true">6.1.</strong> Scheduling</a></li><li class="chapter-item expanded "><a href="handoffs.html"><strong aria-hidden="true">6.2.</strong> Handoffs</a></li><li class="chapter-item expanded "><a href="networking.html"><strong aria-hidden="true">6.3.</strong> Networking</a></li><li class="chapter-item expanded "><a href="in-out_trees.html"><strong aria-hidden="true">6.4.</strong> Subgraph In-Out Trees</a></li></ol></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">7.</strong> TODO</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">8.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hydroflow Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/hydro-project/hydroflow">Hydroflow</a> is a compiler for low-latency 
dataflow programs, written in Rust. Hydroflow is the runtime library for the 
<a href="./ecosystem.html">Hydro language stack</a>, which is under development
as a complete compiler stack for distributed programming languages. </p>
<p>Hydroflow is designed with two goals in mind:</p>
<ul>
<li>Expert developers can program Hydroflow directly to build components in a distributed system.</li>
<li>Higher levels of the Hydro stack will offer friendlier languages with more abstractions, and treat Hydroflow as a compiler target.</li>
</ul>
<p>Hydroflow provides a DSL—a <em>surface syntax</em>—embedded in Rust, which compiles to high-efficiency machine code. 
As the lowest level of the Hydro stack, Hydroflow
requires some knowledge of Rust to use. </p>
<h2 id="this-book"><a class="header" href="#this-book">This Book</a></h2>
<p>This book will teach you how to set up your environment to get started with Hydroflow, and how to program in the Hydroflow surface syntax.</p>
<p>Keep in mind that Hydroflow is under active development and is constantly
changing. However the code in this book is tested with the Hydroflow library so should always be up-to-date.</p>
<p>If you have any questions, feel free to <a href="https://github.com/hydro-project/hydroflow/issues/new">create an issue on Github</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>This section will get you up and running with Rust and Hydroflow, and work you 
through a set of concrete examples illustrating much of what you need to know to
get productive with Hydroflow.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>This section explains how to get Hydroflow running, either for development or
usage, even if you are not familiar with Rust development.</p>
<h2 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h2>
<p>First you will need to install Rust. We recommend the conventional installation
method, <code>rustup</code>, which allows you to easily manage and update Rust versions.</p>
<p><a href="https://www.rust-lang.org/tools/install"><strong>Install Rust</strong></a></p>
<p>The link in the previous line will take you to the Rust website that shows you how to
install <code>rustup</code> and the Rust package manager <code>cargo</code> (and the
internally-used <code>rustc</code> compiler). <code>cargo</code> is Rust's main development tool,
used for building, running, and testing Rust code.</p>
<p>The following <code>cargo</code> commands will come in handy:</p>
<ul>
<li><code>cargo check --all-targets</code> - Checks the workspace for any compile-time
errors.</li>
<li><code>cargo build --all-targets</code> - Builds all projects/tests/benchmarks/examples
in the workspace.</li>
<li><code>cargo clean</code> - Cleans the build cache, sometimes needed if the build is
acting up.</li>
<li><code>cargo test</code> - Runs tests in the workspace.</li>
<li><code>cargo run -p hydroflow --example &lt;example name&gt;</code> - Run an example program in
<code>hydroflow/examples</code>.</li>
</ul>
<p>To learn Rust see the official <a href="https://www.rust-lang.org/learn">Learn Rust page</a>.
Here are some good resources:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/"><em>The Rust Programming Language</em>, AKA &quot;The Book&quot;</a></li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust With Entirely Too Many Linked Lists</a>
is a good way to learn Rust's ownership system and its
implications.</li>
</ul>
<p>In this book we will be using the Hydroflow template generator, which we recommend
as a starting point for your Hydroflow projects. For this purpose you
will need to install the <code>cargo-generate</code> tool:</p>
<pre><code class="language-bash">cargo install cargo-generate
</code></pre>
<h2 id="vs-code-setup"><a class="header" href="#vs-code-setup">VS Code Setup</a></h2>
<p>We recommend using VS Code with the <code>rust-analyzer</code> extension (and NOT the
<code>Rust</code> extension). To enable the pre-release version of <code>rust-analyzer</code>
(required by some new nightly syntax we use, at least until 2022-03-14), click
the &quot;Switch to Pre-Release Version&quot; button next to the uninstall button.</p>
<h2 id="setting-up-a-hydroflow-project"><a class="header" href="#setting-up-a-hydroflow-project">Setting up a Hydroflow Project</a></h2>
<p>The easiest way to get started with Hydroflow is to begin with a template project. 
Create a directory where you'd like to put that project, direct your terminal there and run:</p>
<pre><code class="language-bash">cargo generate hydro-project/hydroflow-template
</code></pre>
<p>You will be prompted to name your project. The <code>cargo generate</code> command will create a subdirectory 
with the relevant files and folders. </p>
<p>As part of generating the project, the <code>hydroflow</code> library will be downloaded as a dependency.
You can then open the project in VS Code or IDE of your choice, or
you can simply build the template project with <code>cargo build</code>.</p>
<pre><code class="language-bash">cd &lt;project name&gt;
cargo build
</code></pre>
<p>This should return successfully.</p>
<p>The template provides a simple working example of a Hydroflow program.
As a sort of &quot;hello, world&quot; of distributed systems, it implements an &quot;echo server&quot; that
simply echoes back the messages you sent it; it also implements a client to test the server. 
We will replace the code in that example with our own, but it's a good idea to run it first to make sure everything is working.</p>
<blockquote>
<p>We call a running Hydroflow binary a <em>transducer</em>.</p>
</blockquote>
<p>Start by running a transducer for the server:</p>
<pre><code class="language-console">% cargo run -- --role server
Listening on 127.0.0.1:&lt;port&gt;
Server live!
</code></pre>
<p>Take note of the server's port number, and in a separate terminal, start a client transducer:</p>
<pre><code class="language-console">% cd &lt;project name&gt;
% cargo run -- --role client --server-addr 127.0.0.1:&lt;port&gt;
Listening on 127.0.0.1:&lt;client_port&gt;
Connecting to server at 127.0.0.1:&lt;port&gt;
Client live!
</code></pre>
<p>Now you can type strings in the client, which are sent to the server, echo'ed back, and printed at the client. E.g.:</p>
<pre><code class="language-console">Hello!
2022-12-20 18:51:50.181647 UTC: Got Echo { payload: &quot;Hello!&quot;, ts: 2022-12-20T18:51:50.180874Z } from 127.0.0.1:61065
</code></pre>
<h2 id="alternative-checking-out-the-hydroflow-repository"><a class="header" href="#alternative-checking-out-the-hydroflow-repository">Alternative: Checking out the Hydroflow Repository</a></h2>
<p>This book will assume you are using the template project, but some
Rust experts may want to get started with Hydroflow by cloning and working in the
repository directly. 
You should fork the repository if you want to push your
changes.</p>
<p>To clone the repo, run:</p>
<pre><code class="language-bash">git clone git@github.com:hydro-project/hydroflow.git
</code></pre>
<p>Hydroflow requires nightly Rust, but the repo is already configured for it via
<code>rust-toolchain.toml</code>.</p>
<p>You can then open the repo in VS Code or IDE of your choice. In VS Code, <code>rust-analyzer</code>
will provide inline type and error messages, code completion, etc.</p>
<p>To work with the repository, it's best to start with an &quot;example&quot;, found in the
<a href="https://github.com/hydro-project/hydroflow/tree/main/hydroflow/examples"><code>hydroflow/examples</code> folder</a>.
These examples are included via the <a href="https://github.com/hydro-project/hydroflow/blob/main/hydroflow/Cargo.toml"><code>hydroflow/Cargo.toml</code> file</a>,
so make sure to add your example there if you create a new one. The simplest
example is the <a href="https://github.com/hydro-project/hydroflow/blob/main/hydroflow/examples/echoserver/main.rs"><code>echo server</code></a>.</p>
<p>The Hydroflow repository is set up as a <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">workspace</a>,
i.e. a repo containing a bunch of separate packages, <code>hydroflow</code> is just the
main one. So if you want to work in a proper separate cargo package, you can
create one and add it into the <a href="https://github.com/hydro-project/hydroflow/blob/main/Cargo.toml">root <code>Cargo.toml</code></a>,
much like the <a href="https://github.com/hydro-project/hydroflow-template/blob/main/Cargo.toml">provided template</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simplest-example"><a class="header" href="#simplest-example">Simplest Example</a></h1>
<blockquote>
<p>In this example we will cover:</p>
<ul>
<li>Modifying the Hydroflow template project</li>
<li>How Hydroflow program specs are embedded inside Rust </li>
<li>How to execute a simple Hydroflow program</li>
<li>Two Hydroflow operators: <code>source_iter</code> and <code>for_each</code></li>
</ul>
</blockquote>
<p>Lets start out with the simplest possible Hydroflow program, which prints out
the numbers in <code>0..10</code>.</p>
<p>Create a clean template project:</p>
<pre><code class="language-console">% cargo generate hydro-project/hydroflow-template
⚠️   Favorite `hydro-project/hydroflow-template` not found in config, using it as a git repository: https://github.com/hydro-project/hydroflow-template.git
🤷   Project Name: simple
🔧   Destination: /Users/jmh/code/sussudio/simple ...
🔧   project-name: simple ...
🔧   Generating template ...
[ 1/11]   Done: .gitignore                                                      [ 2/11]   Done: Cargo.lock                                                      [ 3/11]   Done: Cargo.toml                                                      [ 4/11]   Done: README.md                                                       [ 5/11]   Done: rust-toolchain.toml                                             [ 6/11]   Done: src/client.rs                                                   [ 7/11]   Done: src/helpers.rs                                                  [ 8/11]   Done: src/main.rs                                                     [ 9/11]   Done: src/protocol.rs                                                 [10/11]   Done: src/server.rs                                                   [11/11]   Done: src                                                             🔧   Moving generated files into: `&lt;dir&gt;/simple`...
💡   Initializing a fresh Git repository
✨   Done! New project created &lt;dir&gt;/simple
</code></pre>
<p>Change directory into the resulting <code>simple</code> folder or open it in your IDE. Then edit the <code>src/main.rs</code> file, replacing 
<em>all</em> of its contents with the following code:</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
    let mut flow = hydroflow_syntax! {
        source_iter(0..10) -&gt; for_each(|n| println!(&quot;Hello {}&quot;, n));
    };

    flow.run_available();
}
</code></pre></pre>
<p>And then run the program:</p>
<pre><code class="language-console">% cargo run
Hello 0
Hello 1
Hello 2
Hello 3
Hello 4
Hello 5
Hello 6
Hello 7
Hello 8
Hello 9
</code></pre>
<h2 id="understanding-the-code"><a class="header" href="#understanding-the-code">Understanding the Code</a></h2>
<p>Although this is a trivial program, it's useful to go through it line by line.</p>
<pre><code class="language-rust ignore">use hydroflow::hydroflow_syntax;
</code></pre>
<p>This import gives you everything you need from Hydroflow to write code with Hydroflow's 
<a href="./surface_syntax.html"><em>surface syntax</em></a>.</p>
<p>Next, inside the main method we specify a flow by calling the 
<code>hydroflow_syntax!</code> macro. We assign the resulting <code>Hydroflow</code> instance to
a mutable variable <code>flow</code>––mutable because we will be changing its status when we run it.</p>
<pre><code class="language-rust ignore"><span class="boring">use hydroflow::hydroflow_syntax;
</span>pub fn main() {
    let mut flow = hydroflow_syntax! {
        source_iter(0..10) -&gt; for_each(|n| println!(&quot;Hello {}&quot;, n));
    };
</code></pre>
<p>Hydroflow surface syntax defines a &quot;flow&quot; consisting of <em>operators</em> connected via <code>-&gt;</code> arrows.
This simplest example uses a simple two-step linear flow.
It starts with a <a href="./surface_ops.gen.html#source_iter"><code>source_iter</code></a> operator that takes the Rust
iterator <code>0..10</code> and iterates it to emit the 
numbers 0 through 9. That operator then passes those numbers along the <code>-&gt;</code> arrow downstream to a 
<a href="./surface_ops.gen.html#for_each"><code>for_each</code></a> operator that invokes its closure argument to print each
item passed in.</p>
<p>The Hydroflow surface syntax is merely a <em>specification</em>; it does not actually do anything
until we run it.
We run the flow from within Rust via the <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run_available"><code>run_available()</code> method</a>.</p>
<pre><code class="language-rust ignore">    flow.run_available();
</code></pre>
<p>Note that <code>run_available()</code> runs the Hydroflow graph until no more work is immediately
available. In this example flow, running the graph drains the iterator completely, so no
more work will <em>ever</em> be available. In future examples we will use external inputs such as
network ingress, in which case more work might appear at any time. </p>
<h3 id="a-note-on-project-structure"><a class="header" href="#a-note-on-project-structure">A Note on Project Structure</a></h3>
<p>The template project is intended to be a starting point for your own Hydroflow project, and you can add files and directories as you see fit. The only requirement is that the <code>src/main.rs</code> file exists and contains a <code>main()</code> function.</p>
<p>In this simplest example we did not use a number of the files in the template: notably everything in the <code>src/</code> subdirectory other than <code>src/main.rs</code>. If you'd like to delete those extraneous files you can do so, but it's not necessary, and we'll use them in subsequent examples. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h1>
<blockquote>
<p>In this example we will cover some additional standard Hydroflow operators:</p>
<ul>
<li><a href="./surface_ops.gen.html#map"><code>map</code></a></li>
<li><a href="./surface_ops.gen.html#filter"><code>filter</code></a></li>
<li><a href="./surface_ops.gen.html#flatten"><code>flatten</code></a></li>
<li><a href="./surface_ops.gen.html#filter_map"><code>filter_map</code></a></li>
<li><a href="./surface_ops.gen.html#flat_map"><code>flat_map</code></a></li>
</ul>
</blockquote>
<p>Lets build on the simplest example to explore some of the operators available
in Hydroflow. You may be familiar with operators such as <a href="./surface_ops.gen.html#map"><code>map(...)</code></a>,
<a href="./surface_ops.gen.html#filter"><code>filter(...)</code></a>, <a href="./surface_ops.gen.html#flatten"><code>flatten</code>(...)</a>,
etc. from Rust iterators or from other programming languages, and these are
also available in Hydroflow.</p>
<p>In your <code>simple</code> project, replace the contents of <code>src/main.rs</code> with the following:</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
    let mut flow = hydroflow_syntax! {
        source_iter(0..10)
            -&gt; map(|n| n * n)
            -&gt; filter(|&amp;n| n &gt; 10)
            -&gt; map(|n| (n..=n+1))
            -&gt; flatten()
            -&gt; for_each(|n| println!(&quot;Howdy {}&quot;, n));
    };

    flow.run_available();
}
</code></pre></pre>
<p>Let's take this one operator at a time, starting after the <code>source_iter</code> operator we saw in the previous example.</p>
<ul>
<li>
<p><code>-&gt; map(|n| n * n)</code> transforms each element individually as it flows through the subgraph.
In this case, we square each number. </p>
</li>
<li>
<p>Next, <code>-&gt; filter(|&amp;n| n &gt; 10)</code> only passes along squared numbers that are greater than 10.</p>
</li>
<li>
<p>The subsequent <code>-&gt; map(|n| (n..=n+1))</code> uses standard Rust syntax to convert each number <code>n</code> into a
<a href="https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html"><code>RangeInclusive</code></a>
[<code>n</code>, <code>n+1</code>]. </p>
</li>
<li>
<p>The <code>-&gt; flatten()</code> operator converts the ranges back
into a stream of the individual numbers which they contain.</p>
</li>
<li>
<p>Finally we use the now-familiar <code>for_each</code> operator to print each number.</p>
</li>
</ul>
<p>Now let's run the program:</p>
<pre><code class="language-console">% cargo run
&lt;build output&gt;
Howdy 16
Howdy 17
Howdy 25
Howdy 26
Howdy 36
Howdy 37
Howdy 49
Howdy 50
Howdy 64
Howdy 65
Howdy 81
Howdy 82
</code></pre>
<h2 id="rewriting-with-composite-operators"><a class="header" href="#rewriting-with-composite-operators">Rewriting with Composite Operators</a></h2>
<p>We can also express the same program with more aggressive use of composite operators like
<a href="./surface_ops.gen.html#filtermap"><code>filter_map()</code></a> and <a href="./surface_ops.gen.html#flat_map"><code>flat_map()</code></a>. Hydroflow will compile these down to the same
machine code.</p>
<p>Replace the contents of <code>src/main.rs</code> with the following:</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;
 pub fn main() {
    let mut flow = hydroflow_syntax! {
        source_iter(0..10)
        -&gt; filter_map(|n| {
            let n2 = n * n;
            if n2 &gt; 10 {
                Some(n2)
            }
            else {
                None
            }
        })
        -&gt; flat_map(|n| (n..=n+1))
        -&gt; for_each(|n| println!(&quot;G'day {}&quot;, n));
    };

    flow.run_available();
}
</code></pre></pre>
<p>Results:</p>
<pre><code class="language-console">% cargo run
&lt;build output&gt;
G'day 16
G'day 17
G'day 25
G'day 26
G'day 36
G'day 37
G'day 49
G'day 50
G'day 64
G'day 65
G'day 81
G'day 82
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-example-with-streaming-input"><a class="header" href="#an-example-with-streaming-input">An Example With Streaming Input</a></h1>
<blockquote>
<p>In this example we will cover:</p>
<ul>
<li>the input <code>channel</code> concept, which streams data in from outside the Hydroflow spec</li>
<li>the <a href="./surface_ops.gen.html#source_stream"><code>source_stream</code></a> operator that brings channel input into Hydroflow</li>
<li>Rust syntax to programmatically send data to a (local) channel</li>
</ul>
</blockquote>
<p>In our previous examples, data came from within the Hydroflow spec, via Rust iterators and the <a href="./surface_ops.gen.html#source_iter"><code>source_iter</code></a> operator. In most cases, however, data comes from outside the Hydroflow spec. In this example, we'll see a simple version of this idea, with data being generated on the same machine and sent into the channel programmatically via Rust.</p>
<p>For discussion, we start with a skeleton much like before:</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
    let mut hydroflow = hydroflow_syntax! {
        // code will go here
    };

    hydroflow.run_available();
}
</code></pre></pre>
<p><strong>TODO:</strong> Make the following less intimidating to users who are not Tokio experts.</p>
<p>To add a new external input
channel, we can use the <code>hydroflow::util::unbounded_channel()</code> function in Rust before we declare the Hydroflow spec:</p>
<pre><code class="language-rust  ignore">    let (input_example, example_recv) = hydroflow::util::unbounded_channel::&lt;usize&gt;();
</code></pre>
<p>Under the covers, this is a <a href="https://docs.rs/tokio/latest/tokio/sync/mpsc/fn.unbounded_channel.html">multiple-producer/single-consumer (<code>mpsc</code>) channel</a> provided by Rust's <a href="https://docs.rs/tokio/latest/tokio">tokio</a> library, which is usually the appropriate choice for an inbound Hydroflow stream.
Think of it as a high-performance &quot;mailbox&quot; that any sender can fill with well-typed data.</p>
<p>The Rust <code>::&lt;usize&gt;</code> syntax uses what is affectionately
called the &quot;turbofish&quot;, which is how type parameters (generic arguments) are
supplied to generic types and functions. In this case it specifies that this tokio channel
transmits items of type <code>usize</code>.
The returned <code>example_recv</code> value can be used via a <a href="./surface_ops.gen.html#source_stream"><code>source_stream</code></a>
to build a Hydroflow subgraph just like before. </p>
<p>Here is the same program as before, but using the
input channel. Back in the <code>simple</code> project, replace the contents of <code>src/main.rs</code> with the following:</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
   // Create our channel input
    let (input_example, example_recv) = hydroflow::util::unbounded_channel::&lt;usize&gt;();

    let mut flow = hydroflow_syntax! {
         source_stream(example_recv)
        -&gt; filter_map(|n: usize| {
            let n2 = n * n;
            if n2 &gt; 10 {
                Some(n2)
            }
            else {
                None
            }
        })
        -&gt; flat_map(|n| (n..=n+1))
        -&gt; for_each(|n| println!(&quot;Ahoy, {}&quot;, n));
    };

    println!(&quot;A&quot;);
    input_example.send(1).unwrap();
    input_example.send(0).unwrap();
    input_example.send(2).unwrap();
    input_example.send(3).unwrap();
    input_example.send(4).unwrap();
    input_example.send(5).unwrap();

    flow.run_available();

    println!(&quot;B&quot;);
    input_example.send(6).unwrap();
    input_example.send(7).unwrap();
    input_example.send(8).unwrap();
    input_example.send(9).unwrap();
    flow.run_available();
}
</code></pre></pre>
<pre><code class="language-console">% cargo run
&lt;build output&gt;
A
Ahoy, 16
Ahoy, 17
Ahoy, 25
Ahoy, 26
B
Ahoy, 36
Ahoy, 37
Ahoy, 49
Ahoy, 50
Ahoy, 64
Ahoy, 65
Ahoy, 81
Ahoy, 82
</code></pre>
<p>At the bottom of <code>main.rs</code> we can see how to programatically supply <code>usize</code>-typed inputs with the tokio 
<code>.send()</code> method.  We call Rust's <code>.unwrap()</code> method to ignore the error messages from 
<code>.send()</code> in this simple case.  In later examples we'll see how to 
allow for data coming in over a network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-neighbors"><a class="header" href="#graph-neighbors">Graph Neighbors</a></h1>
<blockquote>
<p>In this example we cover:</p>
<ul>
<li>Assigning sub-flows to variables</li>
<li>Our first multi-input operator, <a href="./surface_ops.gen.html#join"><code>join</code></a></li>
<li>Indexing multi-input operators by prepending a bracket expression</li>
<li>The <a href="./surface_ops.gen.html#unique"><code>unique</code></a> operator for removing duplicates from a stream</li>
<li>Visualizing hydroflow code via <code>flow.meta_graph().to_mermaid()</code></li>
<li>A first exposure to the concepts of <em>strata</em> and <em>ticks</em></li>
</ul>
</blockquote>
<p>So far all the operators we've used have one input and one output and therefore
create a linear flow of operators. Let's now take a look at a Hydroflow program containing
an operator which has multiple inputs; in the following examples we'll extend this to
multiple outputs.</p>
<p>To motivate this, we are going to start out on a little project of building a flow-based algorithm 
for the problem of <em>graph reachability</em>. 
Given an abstract graph—represented as data in the form of a streaming list of edges—which 
vertices can be reached from a vertex passed in as the <code>origin</code>? It turns out this is fairly 
naturally represented as a dataflow program. </p>
<blockquote>
<p><strong>Note on terminology</strong>: In each of the next few examples, we're going to write a Hydroflow program (a dataflow graph) to process data that itself represents some other graph! To avoid confusion, in these examples, we'll refer to the Hydroflow program as a &quot;flow&quot; or &quot;program&quot;, and the data as a &quot;graph&quot; of &quot;edges&quot; and &quot;vertices&quot;.</p>
</blockquote>
<h2 id="but-first-graph-neighbors"><a class="header" href="#but-first-graph-neighbors">But First: Graph Neighbors</a></h2>
<p>Graph reachability exercises a bunch of concepts at once, so we'll start here with a simpler flow that 
finds graph <em>neighbors</em>: vertices that are just one hop away. </p>
<p>Our graph neighbors Hydroflow program will take
our initial <code>origin</code> vertex as one input, and join it another input that streams in all the edges—this 
join will stream out the vertices that are one hop (edge) away from the starting vertex. </p>
<p>Here is an <em>intuitive</em> diagram of that dataflow program (we'll see complete, autogenerated Hydroflow diagrams
below):</p>
<pre class="mermaid">graph TD
  subgraph sources
    01[Stream of Edges]
  end
  subgraph neighbors of origin
    00[Origin Vertex]
    20(&quot;V ⨝ E&quot;)
    40[Output]

    00 --&gt; 20
    
    01 ---&gt; 20
    20 --&gt; 40
    
  end
</pre>
<p>Lets take a look at some Hydroflow code that implements the program. In your <code>simple</code> project,
replace the contents of <code>src/main.rs</code> with the following:</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
    // An edge in the input data = a pair of `usize` vertex IDs.
    let (edges_send, edges_recv) = hydroflow::util::unbounded_channel::&lt;(usize, usize)&gt;();

    let mut flow = hydroflow_syntax! {
        // inputs: the origin vertex (vertex 0) and stream of input edges
        origin = source_iter(vec![0]);
        stream_of_edges = source_stream(edges_recv);

        // the join
        my_join = join() -&gt; flat_map(|(src, (_, dst))| [src, dst]);
        origin -&gt; map(|v| (v, ())) -&gt; [0]my_join;
        stream_of_edges -&gt; [1]my_join;

        // the output
        my_join -&gt; unique() -&gt; for_each(|n| println!(&quot;Reached: {}&quot;, n));
    };

    println!(
        &quot;{}&quot;,
        flow.meta_graph()
            .expect(&quot;No graph found, maybe failed to parse.&quot;)
            .to_mermaid()
    );
    edges_send.send((0, 1)).unwrap();
    edges_send.send((2, 4)).unwrap();
    edges_send.send((3, 4)).unwrap();
    edges_send.send((1, 2)).unwrap();
    edges_send.send((0, 3)).unwrap();
    edges_send.send((0, 3)).unwrap();
    flow.run_available();
}
</code></pre></pre>
<p>Run the program and focus on the last three lines of output, which come from <code>flow.run_available()</code>:</p>
<pre><code class="language-console">% cargo run
&lt;build output&gt;
&lt;graph output&gt;
Reached: 0
Reached: 3
Reached: 1
</code></pre>
<p>That looks right: the edges we &quot;sent&quot; into the flow that start at <code>0</code> are 
<code>(0, 1)</code> and <code>(0, 3)</code>, so the nodes reachable from <code>0</code> in 0 or 1 hops are <code>0, 1, 3</code>.</p>
<blockquote>
<p>Note: When you run the program you may see the lines printed out in a different order. That's OK; the flow we're defining here is producing a <code>set</code> of nodes, so the order in which they are printed out is not specified. The <a href="./surface_ops.gen.html#sort_by"><code>sort_by</code></a> operator can be used to sort the output of a flow.</p>
</blockquote>
<h2 id="examining-the-hydroflow-code"><a class="header" href="#examining-the-hydroflow-code">Examining the Hydroflow Code</a></h2>
<p>In the code, we want to start out with the origin vertex, <code>0</code>,
and the stream of edges coming in. Because this flow is a bit more complex
than our earlier examples, we break it down into named &quot;subflows&quot;, assigning them variable
names that we can reuse. Here we specify two subflows, <code>origin</code> and <code>stream_of_edges</code>:</p>
<pre><code class="language-rust ignore">    origin = source_iter(vec![0]);
    stream_of_edges = source_stream(edges_recv);
</code></pre>
<p>The Rust syntax <code>vec![0]</code> constructs a vector with a single element, <code>0</code>, which we iterate
over using <code>source_iter</code>.</p>
<p>We then set up a <a href="./surface_ops.gen.html#join"><code>join()</code></a> that we
name <code>my_join</code>, which acts like a SQL inner join. </p>
<pre><code class="language-rust ignore">    // the join
    my_join = join() -&gt; flat_map(|(src, (_, dst))| [src, dst]);
    origin -&gt; map(|v| (v, ())) -&gt; [0]my_join;
    stream_of_edges -&gt; [1]my_join;
</code></pre>
<p>First, note the syntax for passing data into a subflow with multiple inputs requires us to <em>prepend</em> 
an input index (starting at <code>0</code>) in square brackets to the multi-input variable name or operator.  In this example we have <code>-&gt; [0]my_join</code>
and <code>-&gt; [1]my_join</code>.</p>
<p>Hydroflow's <code>join()</code> API requires
a little massaging of its inputs to work properly.
The inputs must be of the form of a pair of elements <code>(K, V1)</code>
and <code>(K, V2)</code>, and the operator joins them on equal keys <code>K</code> and produces an
output of <code>(K, (V1, V2))</code> elements. In this case we only want to join on the key <code>v</code> and
don't have any corresponding value, so we feed <code>origin</code> through a <a href="./surface_ops.gen.html#map"><code>map()</code></a>
to generate <code>(v, ())</code> elements as the first join input. </p>
<p>The <code>stream_of_edges</code> are <code>(src, dst)</code> pairs,
so the join's output is <code>(src, ((), dst))</code> where <code>dst</code> are new neighbor
vertices. So the <code>my_join</code> variable feeds the output of the join through a <code>flat_map</code> to extract the pairs into 2-item arrays, which are flattened to give us a list of all vertices reached.
Finally we print the neighbor vertices as follows:</p>
<pre><code class="language-rust ignore">    my_join -&gt; unique() -&gt; for_each(|n| println!(&quot;Reached: {}&quot;, n));
</code></pre>
<p>The <a href="./surface_ops.gen.html#unique">unique</a> operator removes duplicates from the stream to make things more readable. Note that <code>unique</code> does not run in a streaming fashion, which we will talk about more <a href="example_4_neighbors.html#strata-and-ticks">below</a>.</p>
<p>There's
also some extra code here, <code>flow.meta_graph().expect(...).to_mermaid()</code>, which tells
Hydroflow to
generate a diagram rendered by <a href="https://mermaid-js.github.io/">Mermaid</a> showing
the structure of the graph, and print it to stdout. You can copy that text and paste it into the <a href="https://mermaid-js.github.io/mermaid-live-editor/">Mermaid Live Editor</a> to see the graph, which should look as follows:</p>
<pre class="mermaid">%%{init: {'theme': 'base', 'themeVariables': {'clusterBkg':'#ddd'}}}%%
flowchart TD
classDef pullClass fill:#02f,color:#fff,stroke:#000
classDef pushClass fill:#ff0,stroke:#000
linkStyle default stroke:#aaa,stroke-width:4px,color:red,font-size:1.5em;
subgraph &quot;sg_1v1 stratum 0&quot;
    1v1[\&quot;(1v1) &lt;tt&gt;source_iter(vec! [0])&lt;/tt&gt;&quot;/]:::pullClass
    2v1[\&quot;(2v1) &lt;tt&gt;source_stream(edges_recv)&lt;/tt&gt;&quot;/]:::pullClass
    5v1[\&quot;(5v1) &lt;tt&gt;map(| v | (v, ()))&lt;/tt&gt;&quot;/]:::pullClass
    3v1[\&quot;(3v1) &lt;tt&gt;join()&lt;/tt&gt;&quot;/]:::pullClass
    4v1[\&quot;(4v1) &lt;tt&gt;flat_map(| (src, (_, dst)) | [src, dst])&lt;/tt&gt;&quot;/]:::pullClass
    1v1---&gt;5v1
    2v1--1---&gt;3v1
    5v1--0---&gt;3v1
    3v1---&gt;4v1
end
subgraph &quot;sg_2v1 stratum 1&quot;
    6v1[/&quot;(6v1) &lt;tt&gt;unique()&lt;/tt&gt;&quot;\]:::pushClass
    7v1[/&quot;(7v1) &lt;tt&gt;for_each(| n | println! (&amp;quot;Reached: {}&amp;quot;, n))&lt;/tt&gt;&quot;\]:::pushClass
    6v1---&gt;7v1
end
4v1---&gt;8v1
8v1[&quot;(8v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
8v1===o6v1
</pre>
<p>Notice in the mermaid graph how Hydroflow separates the <code>unique</code> operator and its downstream dependencies into their own
<em>stratum</em> (plural: <em>strata</em>). Note also the edge coming into <code>unique</code> is bold and ends in a ball: this is because the input to <code>unique</code> is 
``blocking'', meaning that <code>unique</code> should not run until all of the input on that edge has been received.
The stratum boundary before <code>unique</code> ensures that the blocking property is respected.</p>
<p>You may also be wondering why the nodes in the graph have different colors (and shapes, for readers who cannot distinguish
colors easily). The answer has nothing to do with the meaning of the program, only with the way that Hydroflow compiles 
operators into Rust. Simply put, blue (wide-topped) boxes <em>pull</em> data, yellow (wide-bottomed) boxes <em>push</em> data, and the <code>handoff</code> is a special operator that buffers pushed data for subsequent pulling. Hydroflow always places a handoff
between a push producer and a pull consumer, for reasons explained in the <a href="./architecture.html">Architecture</a> chapter.</p>
<h2 id="strata-and-ticks"><a class="header" href="#strata-and-ticks">Strata and Ticks</a></h2>
<p>Hydroflow runs each stratum
in order, one at a time, ensuring all values are computed
before moving on to the next stratum. Between strata we see a <em>handoff</em>, which logically buffers the 
output of the first stratum, and delineates the separation of execution between the 2 strata.</p>
<p>After all strata are run, Hydroflow returns to the first stratum; this begins the next <em>tick</em>. This doesn't really matter for this example, but it is important for long-running Hydroflow services that accept input from the outside world. More on this topic in the chapter on <a href="./life_and_times.html">time</a>.</p>
<p>Returning to the code, if you read the <code>edges_send</code> calls carefully, you'll see that the example data 
has vertices (<code>2</code>, <code>4</code>) that are more than one hop away from <code>0</code>, which were
not output by our simple program. To extend this example to graph <em>reachability</em>, 
we need to recurse: find neighbors of our neighbors, neighbors of our neighbors' neighbors, and so on. In Hydroflow,
this is done by adding a loop to the flow, as we'll see in our <a href="example_5_reachability.html">next example</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-reachability"><a class="header" href="#graph-reachability">Graph Reachability</a></h1>
<blockquote>
<p>In this example we cover:</p>
<ul>
<li>Implementing a recursive algorithm (graph reachability) via cyclic dataflow</li>
<li>Operators to merge data from multiple inputs (<a href="./surface_ops.gen.html#merge"><code>merge</code></a>), and send data to multiple outputs (<a href="./surface_ops.gen.html#tee"><code>tee</code></a>)</li>
<li>Indexing multi-output operators by appending a bracket expression</li>
<li>An example of how a cyclic dataflow in one stratum executes to completion before starting the next stratum. </li>
</ul>
</blockquote>
<p>To expand from graph neighbors to graph reachability, we want to find vertices that are connected not just to <code>origin</code>,
but also to vertices reachable <em>transitively</em> from <code>origin</code>. Said differently, a vertex is reachable from <code>origin</code> if it is
one of two cases: </p>
<ol>
<li>a neighbor of <code>origin</code> <em>or</em> </li>
<li>a neighbor of some other vertex that is itself reachable from <code>origin</code>. </li>
</ol>
<p>It turns out this is a very small change to our Hydroflow program! Essentially we want to take <em>all</em> the reached vertices we found in our graph neighbors program,
and treat them recursively just as we treated <code>origin</code>.
To do this in a language like Hydroflow, we introduce a cycle in the flow:
we take the join output and have it
flow back into the join input. The modified intuitive graph looks like this:</p>
<pre class="mermaid">graph TD
  subgraph sources
    01[Stream of Edges]
  end
  subgraph reachable from origin
    00[Origin Vertex]
    10[Reached Vertices]
    20(&quot;V ⨝ E&quot;)
    40[Output]

    00 --&gt; 10
    10 --&gt; 20
    20 --&gt; 10

    01 --&gt; 20
    20 --&gt; 40
    
  end
</pre>
<p>Note that we added a <code>Reached Vertices</code> box to the diagram to merge the two inbound edges corresponding to our 
two cases above. Similarly note that the join box <code>V ⨝ E</code> now has two <em>outbound</em> edges; the sketch omits the operator 
to copy (&quot;tee&quot;) the output along 
two paths.</p>
<p>Now lets look at a modified version of our <a href="example_4_neighbors.html">graph neighbor</a> code that implements this full program, including the loop as well as the Hydroflow <a href="./surface_ops.gen.html#merge"><code>merge</code></a> and <a href="./surface_ops.gen.html#tee"><code>tee</code></a>.
Modify src/main.rs to look like this:</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
    // An edge in the input data = a pair of `usize` vertex IDs.
    let (edges_send, edges_recv) = hydroflow::util::unbounded_channel::&lt;(usize, usize)&gt;();

    let mut flow = hydroflow_syntax! {
        // inputs: the origin vertex (vertex 0) and stream of input edges
        origin = source_iter(vec![0]);
        stream_of_edges = source_stream(edges_recv);
        reached_vertices = merge();
        origin -&gt; [0]reached_vertices;

        // the join
        my_join_tee = join() -&gt; flat_map(|(src, ((), dst))| [src, dst]) -&gt; tee();
        reached_vertices -&gt; map(|v| (v, ())) -&gt; [0]my_join_tee;
        stream_of_edges -&gt; [1]my_join_tee;

        // the loop and the output
        my_join_tee[0] -&gt; [1]reached_vertices;
        my_join_tee[1] -&gt; unique() -&gt; for_each(|x| println!(&quot;Reached: {}&quot;, x));
    };

    println!(
        &quot;{}&quot;,
        flow.meta_graph()
            .expect(&quot;No graph found, maybe failed to parse.&quot;)
            .to_mermaid()
    );
    edges_send.send((0, 1)).unwrap();
    edges_send.send((2, 4)).unwrap();
    edges_send.send((3, 4)).unwrap();
    edges_send.send((1, 2)).unwrap();
    edges_send.send((0, 3)).unwrap();
    edges_send.send((0, 3)).unwrap();
    flow.run_available();
}
</code></pre></pre>
<p>And now we get the full set of vertices reachable from <code>0</code>:</p>
<pre><code class="language-console">% cargo run
&lt;build output&gt;
&lt;graph output&gt;
Reached: 3
Reached: 0
Reached: 2
Reached: 4
Reached: 1
</code></pre>
<h2 id="examining-the-hydroflow-code-1"><a class="header" href="#examining-the-hydroflow-code-1">Examining the Hydroflow Code</a></h2>
<p>Let's review the significant changes here. First, in setting up the inputs we have the 
addition of the <code>reached_vertices</code> variable, which uses the <a href="./surface_ops.gen.html#merge">merge()</a> 
op to merge the output of two operators into one. 
We route the <code>origin</code> vertex into it as one input right away:</p>
<pre><code class="language-rust ignore">    reached_vertices = merge();
    origin -&gt; [0]reached_vertices;
</code></pre>
<p>Note the square-bracket syntax for differentiating the multiple inputs to <code>merge()</code>
is the same as that of <code>join()</code> (except that merge can have an unbounded number of inputs,
whereas <code>join()</code> is defined to only have two.)</p>
<p>Now, <code>join()</code> is defined to only have one output. In our program, we want to copy 
the joined output 
output to two places: to the original <code>for_each</code> from above to print output, and <em>also</em> 
back to the <code>merge</code> operator we called <code>reached_vertices</code>.
We feed the <code>join()</code> output 
through a <code>flat_map()</code> as before, and then we feed the result into a <a href="./surface_ops.gen.html#tee"><code>tee()</code></a> operator,
which is the mirror image of <code>merge()</code>:  instead of merging many inputs to one output, 
it copies one input to many different outputs.  Each input element is <em>cloned</em>, in Rust terms, and
given to each of the outputs. The syntax for the outputs of <code>tee()</code> mirrors that of merge: we <em>append</em> 
an output index in square brackets to the <code>tee</code> or variable. In this example we have
<code>my_join_tee[0] -&gt;</code> and <code>my_join_tee[1] -&gt;</code>.</p>
<p>Finally, we process the output of the <code>join</code> as passed through the <code>tee</code>.
One branch pushes reached vertices back up into the <code>reached_vertices</code> variable (which begins with a <code>merge</code>), while the other
prints out all the reached vertices as in the simple program.</p>
<pre><code class="language-rust ignore">        my_join_tee[0] -&gt; [1]reached_vertices;
        my_join_tee[1] -&gt; for_each(|x| println!(&quot;Reached: {}&quot;, x));
</code></pre>
<p>Note the syntax for differentiating the <em>outputs</em> of a <code>tee()</code> is symmetric to that of <code>merge()</code>, 
showing up to the right of the variable rather than the left.</p>
<p>Below is the diagram rendered by <a href="https://mermaid-js.github.io/">mermaid</a> showing
the structure of the full flow:</p>
<pre class="mermaid">%%{init: {'theme': 'base', 'themeVariables': {'clusterBkg':'#ddd'}}}%%
flowchart TD
classDef pullClass fill:#02f,color:#fff,stroke:#000
classDef pushClass fill:#ff0,stroke:#000
linkStyle default stroke:#aaa,stroke-width:4px,color:red,font-size:1.5em;
subgraph &quot;sg_1v1 stratum 0&quot;
    1v1[\&quot;(1v1) &lt;tt&gt;source_iter(vec! [0])&lt;/tt&gt;&quot;/]:::pullClass
    2v1[\&quot;(2v1) &lt;tt&gt;source_stream(edges_recv)&lt;/tt&gt;&quot;/]:::pullClass
    3v1[\&quot;(3v1) &lt;tt&gt;merge()&lt;/tt&gt;&quot;/]:::pullClass
    7v1[\&quot;(7v1) &lt;tt&gt;map(| v | (v, ()))&lt;/tt&gt;&quot;/]:::pullClass
    4v1[\&quot;(4v1) &lt;tt&gt;join()&lt;/tt&gt;&quot;/]:::pullClass
    5v1[/&quot;(5v1) &lt;tt&gt;flat_map(| (src, ((), dst)) | [src, dst])&lt;/tt&gt;&quot;\]:::pushClass
    6v1[/&quot;(6v1) &lt;tt&gt;tee()&lt;/tt&gt;&quot;\]:::pushClass
    10v1[&quot;(10v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
    10v1--1---&gt;3v1
    1v1--0---&gt;3v1
    2v1--1---&gt;4v1
    3v1---&gt;7v1
    7v1--0---&gt;4v1
    4v1---&gt;5v1
    5v1---&gt;6v1
    6v1--0---&gt;10v1
end
subgraph &quot;sg_2v1 stratum 1&quot;
    8v1[/&quot;(8v1) &lt;tt&gt;unique()&lt;/tt&gt;&quot;\]:::pushClass
    9v1[/&quot;(9v1) &lt;tt&gt;for_each(| x | println! (&amp;quot;Reached: {}&amp;quot;, x))&lt;/tt&gt;&quot;\]:::pushClass
    8v1---&gt;9v1
end
6v1--1---&gt;11v1
11v1[&quot;(11v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
11v1===o8v1
</pre>
<p>This is similar to the flow for graph neighbors, but has a few more operators that make it look
more complex. In particular, it includes the <code>merge</code> and <code>tee</code> operators, and a cycle-forming back-edge 
that passes through an auto-generated <code>handoff</code> operator. This <code>handoff</code> is not a stratum boundary (after all, it connects stratum 0 to itself!) It simply enforces the rule that a push producer and a pull consumer must be separated by a <code>handoff</code>. </p>
<p>Meanwhile, note that there is once again a stratum boundary between the stratum 0 with its recursive loop, and stratum 1 that computes <code>unique</code>, with the blocking input. This means that Hydroflow will first run the loop of stratum 0 repeatedly until all the transitive reached vertices are found, before moving on to compute the unique reached vertices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-un-reachability"><a class="header" href="#graph-un-reachability">Graph Un-Reachability</a></h1>
<blockquote>
<p>In this example we cover:</p>
<ul>
<li>Extending a program with additional downstream logic.</li>
<li>Hydroflow's (<a href="./surface_ops.gen.html#difference"><code>difference</code></a>) operator</li>
<li>Further examples of automatic stratification.</li>
</ul>
</blockquote>
<p>Our next example builds on the previous by finding vertices that are <em>not</em> reachable. To do this, we need to capture the set <code>all_vertices</code>, and use a <a href="./surface_ops.gen.html#difference">difference</a> operator to form the difference between that set of vertices and <code>reachable_vertices</code>.</p>
<p>Essentially we want a flow like this:</p>
<pre class="mermaid">graph TD
  subgraph sources
    01[Stream of Edges]
  end
  subgraph reachable from origin
    00[Origin Vertex]
    10[Reached Vertices]
    20(&quot;V ⨝ E&quot;)

    00 --&gt; 10
    10 --&gt; 20
    20 --&gt; 10

    01 --&gt; 20
  end
  subgraph unreachable
    15[All Vertices]
    30(All - Reached)
    01 ---&gt; 15
    15 --&gt; 30
    10 --&gt; 30
    30 --&gt; 40
   end
40[Output]
</pre>
<p>This is a simple augmentation of our previous example. Replace the contents of <code>src/main.rs</code> with the following:</p>
<pre><pre class="playground"><code class="language-rust">use hydroflow::hydroflow_syntax;

pub fn main() {
    // An edge in the input data = a pair of `usize` vertex IDs.
    let (pairs_send, pairs_recv) = hydroflow::util::unbounded_channel::&lt;(usize, usize)&gt;();

    let mut flow = hydroflow_syntax! {
        origin = source_iter(vec![0]);
        stream_of_edges = source_stream(pairs_recv) -&gt; tee();
        reached_vertices = merge()-&gt;tee();
        origin -&gt; [0]reached_vertices;

        // the join for reachable vertices
        my_join = join() -&gt; flat_map(|(src, ((), dst))| [src, dst]);
        reached_vertices[0] -&gt; map(|v| (v, ())) -&gt; [0]my_join;
        stream_of_edges[1] -&gt; [1]my_join;

        // the loop
        my_join -&gt; [1]reached_vertices;

        // the difference all_vertices - reached_vertices
        all_vertices = stream_of_edges[0]
          -&gt; flat_map(|(src, dst)| [src, dst]) -&gt; tee();
        unreached_vertices = difference();
        all_vertices[0] -&gt; [pos]unreached_vertices;
        reached_vertices[1] -&gt; [neg]unreached_vertices;

        // the output
        all_vertices[1] -&gt; unique() -&gt; for_each(|v| println!(&quot;Received vertex: {}&quot;, v));
        unreached_vertices -&gt; for_each(|v| println!(&quot;unreached_vertices vertex: {}&quot;, v));
    };

    println!(
        &quot;{}&quot;,
        flow.meta_graph()
            .expect(&quot;No graph found, maybe failed to parse.&quot;)
            .to_mermaid()
    );

    pairs_send.send((5, 10)).unwrap();
    pairs_send.send((0, 3)).unwrap();
    pairs_send.send((3, 6)).unwrap();
    pairs_send.send((6, 5)).unwrap();
    pairs_send.send((11, 12)).unwrap();
    flow.run_available();
}
</code></pre></pre>
<p>Notice that we are now sending in some new pairs to test this code. The output should be:</p>
<pre><code class="language-console">% cargo run
&lt;build output&gt;
&lt;graph output&gt;
Received vertex: 12
Received vertex: 6
Received vertex: 11
Received vertex: 0
Received vertex: 5
Received vertex: 10
Received vertex: 3
unreached_vertices vertex: 12
unreached_vertices vertex: 11
</code></pre>
<p>Let's review the changes, all of which come at the end of the program. First, 
we remove code to print <code>reached_vertices</code>. Then we define <code>all_vertices</code> to be
the vertices that appear in any edge (using familiar <code>flat_map</code> code from the previous 
examples.) In the last few lines, we wire up a 
<a href="./surface_ops.gen.html#difference">difference</a> operator
to compute the difference between <code>all_vertices</code> and <code>reached_vertices</code>; note 
how we wire up the <code>pos</code> and <code>neg</code> inputs to the <code>difference</code> operator! 
Finally we print both <code>all_vertices</code> and <code>unreached_vertices</code>.</p>
<p>The auto-generated mermaid looks like so:</p>
<pre class="mermaid">%%{init: {'theme': 'base', 'themeVariables': {'clusterBkg':'#ddd'}}}%%
flowchart TD
classDef pullClass fill:#02f,color:#fff,stroke:#000
classDef pushClass fill:#ff0,stroke:#000
linkStyle default stroke:#aaa,stroke-width:4px,color:red,font-size:1.5em;
subgraph &quot;sg_1v1 stratum 0&quot;
    1v1[\&quot;(1v1) &lt;tt&gt;source_iter(vec! [0])&lt;/tt&gt;&quot;/]:::pullClass
    8v1[\&quot;(8v1) &lt;tt&gt;map(| v | (v, ()))&lt;/tt&gt;&quot;/]:::pullClass
    6v1[\&quot;(6v1) &lt;tt&gt;join()&lt;/tt&gt;&quot;/]:::pullClass
    7v1[\&quot;(7v1) &lt;tt&gt;flat_map(| (src, ((), dst)) | [src, dst])&lt;/tt&gt;&quot;/]:::pullClass
    4v1[\&quot;(4v1) &lt;tt&gt;merge()&lt;/tt&gt;&quot;/]:::pullClass
    5v1[/&quot;(5v1) &lt;tt&gt;tee()&lt;/tt&gt;&quot;\]:::pushClass
    15v1[&quot;(15v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
    15v1---&gt;8v1
    1v1--0---&gt;4v1
    8v1--0---&gt;6v1
    6v1---&gt;7v1
    7v1--1---&gt;4v1
    4v1---&gt;5v1
    5v1--0---&gt;15v1
end
subgraph &quot;sg_2v1 stratum 0&quot;
    2v1[\&quot;(2v1) &lt;tt&gt;source_stream(pairs_recv)&lt;/tt&gt;&quot;/]:::pullClass
    3v1[/&quot;(3v1) &lt;tt&gt;tee()&lt;/tt&gt;&quot;\]:::pushClass
    9v1[/&quot;(9v1) &lt;tt&gt;flat_map(| (src, dst) | [src, dst])&lt;/tt&gt;&quot;\]:::pushClass
    10v1[/&quot;(10v1) &lt;tt&gt;tee()&lt;/tt&gt;&quot;\]:::pushClass
    2v1---&gt;3v1
    3v1--0---&gt;9v1
    9v1---&gt;10v1
end
subgraph &quot;sg_3v1 stratum 1&quot;
    12v1[/&quot;(12v1) &lt;tt&gt;unique()&lt;/tt&gt;&quot;\]:::pushClass
    13v1[/&quot;(13v1) &lt;tt&gt;for_each(| v | println! (&amp;quot;Received vertex: {}&amp;quot;, v))&lt;/tt&gt;&quot;\]:::pushClass
    12v1---&gt;13v1
end
subgraph &quot;sg_4v1 stratum 1&quot;
    11v1[\&quot;(11v1) &lt;tt&gt;difference()&lt;/tt&gt;&quot;/]:::pullClass
    14v1[/&quot;(14v1) &lt;tt&gt;for_each(| v | println! (&amp;quot;unreached_vertices vertex: {}&amp;quot;, v))&lt;/tt&gt;&quot;\]:::pushClass
    11v1---&gt;14v1
end
3v1--1---&gt;16v1
5v1--1---&gt;18v1
10v1--0---&gt;17v1
10v1--1---&gt;19v1
16v1[&quot;(16v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
16v1--1---&gt;6v1
17v1[&quot;(17v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
17v1--pos---&gt;11v1
18v1[&quot;(18v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
18v1==neg===o11v1
19v1[&quot;(19v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
19v1===o12v1
</pre>
<p>If you look carefully, you'll see two subgraphs labeled with <code>stratum 0</code>, and two with
<code>stratum 1</code>. The reason the strata were broken into subgraphs has nothing to do with
correctness, but rather the way that Hydroflow graphs are compiled and scheduled, as 
discussed in the chapter on <a href="./architecture.html">Architecture</a>.</p>
<p>All the subgraphs labeled <code>stratum 0</code> are run first to completion, 
and then all the subgraphs labeled <code>stratum 1</code> are run. This captures the requirements of the <code>unique</code> and <code>difference</code> operators used in the lower subgraphs: each has to wait for its full inputs before it can start producing output. Note
how the <code>difference</code> operator has two inputs (labeled <code>pos</code> and <code>neg</code>), and only the <code>neg</code> input shows up as blocking (with the bold edge ending in a ball).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networked-services-1-echoserver"><a class="header" href="#networked-services-1-echoserver">Networked Services 1: EchoServer</a></h1>
<blockquote>
<p>In this example we cover:</p>
<ul>
<li>The standard project template for networked Hydroflow services.</li>
<li>Rust's <code>clap</code> crate for command-line options</li>
<li>Defining message types</li>
<li>Destination operators (e.g. for sending data to a network)</li>
<li>Network sources and dests with built-in serde (<code>source_stream_serde</code>, <code>dest_sink_serde</code>)</li>
<li>The <code>source_stdin</code> source</li>
<li>Long-running services via <code>run_async</code></li>
</ul>
</blockquote>
<p>Our examples up to now have been simple single-node programs, to get us comfortable with Hydroflow's
surface syntax. But the whole point of Hydroflow is to help us write distributed programs or services that run on a cluster of machines!</p>
<p>In this example we'll study the &quot;hello, world&quot; of distributed systems -- a simple echo server. It will listen on a UDP port,
and send back a copy of any message it receives, with a timestamp. We will also look at a client to 
accept strings from the command line, send them to the echo server, and print responses.</p>
<p>We will use a fresh <code>hydroflow-template</code> project template to get started. Change to the directory where you'd like to put your project, and once again run:</p>
<pre><code class="language-bash">cargo generate hydro-project/hydroflow-template
</code></pre>
<p>Then change directory into the resulting project.</p>
<p>The <code>README.md</code> for the template project is a good place to start. It contains a brief overview of the project structure, and how to build and run the example. Here we'll spend more time learning from the code.</p>
<h2 id="hydroflow-project-structure"><a class="header" href="#hydroflow-project-structure">Hydroflow Project Structure</a></h2>
<p>The Hydroflow template project auto-generates this example for us. If you prefer, you can find the source in the <code>examples/echo_server</code> directory of the Hydroflow repository.</p>
<p>The directory structure encouraged by the template is as follows:</p>
<pre><code class="language-txt">project/README.md           # documentation
project/Cargo.toml          # package and dependency info
project/src/main.rs         # main function
project/src/protocol.rs     # message types exchanged between roles
project/src/helpers.rs      # helper functions used by all roles
project/src/&lt;roleA&gt;.rs      # service definition for role A (e.g. server)
project/src/&lt;roleB&gt;.rs      # service definition for role B (e.g. client)
</code></pre>
<p>In the default example, the roles we use are <code>Client</code> and <code>Server</code>, but you can imagine different roles depending on the structure of your service or application.</p>
<h2 id="mainrs"><a class="header" href="#mainrs">main.rs</a></h2>
<p>We start with a <code>main</code> function that parses command-line options, and invokes the appropriate
role-specific service.
After a prelude of imports, we start by defining a Rust <code>enum</code> for the <code>Role</code>s that the service supports. </p>
<pre><code class="language-rust ignore">use clap::{Parser, ValueEnum};
use client::run_client;
use hydroflow::tokio;
use hydroflow::util::{bind_udp_bytes, ipv4_resolve};
use server::run_server;
use std::net::SocketAddr;

mod client;
mod helpers;
mod protocol;
mod server;

#[derive(Clone, ValueEnum, Debug)]
enum Role {
    Client,
    Server,
}
</code></pre>
<p>Following that, we use Rust's <a href="https://docs.rs/clap/latest/clap/"><code>clap</code></a> (Command Line Argument Parser) crate to parse command-line options:</p>
<pre><code class="language-rust ignore">#[derive(Parser, Debug)]
struct Opts {
    #[clap(value_enum, long)]
    role: Role,
    #[clap(long, value_parser = ipv4_resolve)]
    addr: Option&lt;SocketAddr&gt;,
    #[clap(long, value_parser = ipv4_resolve)]
    server_addr: Option&lt;SocketAddr&gt;,
}
</code></pre>
<p>This sets up 3 command-line flags: <code>role</code>, <code>addr</code>, and <code>server_addr</code>. Note how the <code>addr</code> and <code>server_addr</code> flags are made optional via wrapping in a Rust <code>Option</code>; by contrast, the <code>role</code> option is required. The <code>clap</code> crate will parse the command-line options and populate the <code>Opts</code> struct with the values. <code>clap</code> handles parsing the command line strings into the associated Rust types --  the <code>value_parser</code> attribute tells <code>clap</code> to use Hydroflow's <code>ipv4_resolve</code> helper function to parse a string like &quot;127.0.0.1:6552&quot; into a <code>SocketAddr</code>.</p>
<p>This brings us to the <code>main</code> function itself. It is prefaced by a <code>#[tokio::main]</code> attribute, which is a macro that sets up the tokio runtime. This is necessary because Hydroflow uses the tokio runtime for asynchronous execution as a service.</p>
<pre><code class="language-rust ignore">#[tokio::main]
async fn main() {
    // parse command line arguments
    let opts = Opts::parse();
    // if no addr was provided, we ask the OS to assign a local port by passing in &quot;localhost:0&quot;
    let addr = opts
        .addr
        .unwrap_or_else(|| ipv4_resolve(&quot;localhost:0&quot;).unwrap());

    // allocate `outbound` sink and `inbound` stream
    let (outbound, inbound, addr) = bind_udp_bytes(addr).await;
    println!(&quot;Listening on {:?}&quot;, addr);
</code></pre>
<p>After parsing the command line arguments we set up some Rust-based networking. Specifically, for either client or server roles we will need to allocate a UDP socket that is used for both sending and receiving messages. We do this by calling the async <code>bind_udp_bytes</code> function, which is defined in the <code>hydroflow/src/util</code> module. As an async function it returns a <code>Future</code>, so requires appending <code>.await</code>; the function returns a triple of type <code>(UdpSink, UdpSource, SocketAddr)</code>. The first two are the types that we'll use in Hydroflow to send and receive messages, respectively. (Note: your IDE might expand out the <code>UdpSink</code> and <code>UdpSource</code> traits to their more verbose definitions. That is fine; you can ignore those.) The SocketAddr is there in case you specified port 0 in your <code>addr</code> argument, in which case this return value tells you what port the OS has assigned for you.</p>
<p>All that's left is to fire up the code for the appropriate role!</p>
<pre><code class="language-rust ignore">    match opts.role {
        Role::Server =&gt; {
            run_server(outbound, inbound, opts).await;
        }
        Role::Client =&gt; {
            run_client(outbound, inbound, opts).await;
        }
    }
}
</code></pre>
<h2 id="protocolrs"><a class="header" href="#protocolrs">protocol.rs</a></h2>
<p>As a design pattern, it is natural in distributed Hydroflow programs to define various message types in a <code>protocol.rs</code> file with structures shared for use by all the Hydroflow logic across roles. In this simple example, we define only one message type: <code>EchoMsg</code>, and a simple struct with two fields: <code>payload</code> and <code>ts</code> (timestamp). The <code>payload</code> field is a string, and the <code>ts</code> field is a <code>DateTime&lt;Utc&gt;</code>, which is a type from the <a href="https://docs.rs/chrono/latest/chrono/"><code>chrono</code></a> crate. Note the various derived traits on <code>EchoMsg</code>—specifically <code>Serialize</code> and <code>Deserialize</code>—these are required for structs that we send over the network.</p>
<pre><code class="language-rust ignore">use chrono::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(PartialEq, Clone, Serialize, Deserialize, Debug)]
pub struct EchoMsg {
    pub payload: String,
    pub ts: DateTime&lt;Utc&gt;,
}
</code></pre>
<h1 id="serverrs"><a class="header" href="#serverrs">server.rs</a></h1>
<p>Things get interesting when we look at the <code>run_server</code> function. This function is the main entry point for the server. It takes as arguments the <code>outbound</code> and <code>inbound</code> sockets from <code>main</code>, and the <code>Opts</code> (which are ignored). </p>
<p>After printing a cheery message, we get into the Hydroflow code for the server, consisting of three short pipelines.</p>
<pre><code class="language-rust ignore">use crate::protocol::EchoMsg;
use chrono::prelude::*;
use hydroflow::hydroflow_syntax;
use hydroflow::scheduled::graph::Hydroflow;
use hydroflow::util::{UdpSink, UdpStream};
use std::net::SocketAddr;

pub(crate) async fn run_server(outbound: UdpSink, inbound: UdpStream, _opts: crate::Opts) {
    println!(&quot;Server live!&quot;);

    let mut flow: Hydroflow = hydroflow_syntax! {
        // Define a shared inbound channel
        inbound_chan = source_stream_serde(inbound) -&gt; tee();

        // Print all messages for debugging purposes
        inbound_chan[0]
            -&gt; for_each(|(msg, addr): (EchoMsg, SocketAddr)| println!(&quot;{}: Got {:?} from {:?}&quot;, Utc::now(), msg, addr));

        // Echo back the Echo messages with updated timestamp
        inbound_chan[1]
            -&gt; map(|(EchoMsg {payload, ..}, addr)| (EchoMsg { payload, ts: Utc::now() }, addr) ) -&gt; dest_sink_serde(outbound);
    };

    // run the server
    flow.run_async().await;
}
</code></pre>
<p>Lets take the Hydroflow code one statement at a time. </p>
<p>The first pipeline, <code>inbound_chan</code> uses a source operator we have not seen before, <a href="./surface_ops.gen.html#source_stream_serde"><code>source_stream_serde()</code></a>. This is a streaming source like <code>source_stream</code>, but for network streams. It takes a <code>UdpSource</code> as an argument, and has a particular output type: a stream of <code>(T, SocketAddr)</code> pairs where <code>T</code> is some type that implements the <code>Serialize</code> and <code>Deserialize</code> traits (together known as &quot;serde&quot;), and <code>SocketAddr</code> is the network address of the sender of the item. In this case, <code>T</code> is <code>EchoMsg</code>, which we defined in <code>protocol.rs</code>, and the <code>SocketAddr</code> is the address of the client that sent the message. We pipe the result into a <code>tee()</code> for reuse.</p>
<p>The second pipeline is a simple <code>for_each</code> to print the messages received at the server.</p>
<p>The third and final pipeline constructs a response <code>EchoMsg</code> with the local timestamp copied in. It then pipes the result into a <code>dest_XXX</code> operator—the first that we've seen!  A dest is the opposite of a <code>source_XXX</code> operator: it can go at the end of a pipeline and sends data out on a tokio channel. The specific operator used here is <a href="./surface_ops.gen.html#dest_sink_serde"><code>dest_sink_serde()</code></a>. This is a dest operator like <code>dest_sink</code>, but for network streams. It takes a <code>UdpSink</code> as an argument, and requires a particular input type: a stream of <code>(T, SocketAddr)</code> pairs where <code>T</code> is some type that implements the <code>Serialize</code> and <code>Deserialize</code> traits, and <code>SocketAddr</code> is the network address of the destination. In this case, <code>T</code> is once again <code>EchoMsg</code>, and the <code>SocketAddr</code> is the address of the client that sent the original message.</p>
<p>The remaining line of code runs the server. The <code>run_async()</code> function is a method on the <code>Hydroflow</code> type. It is an async function, so we append <code>.await</code> to the call. The program will block on this call until the server is terminated.</p>
<h2 id="clientrs"><a class="header" href="#clientrs">client.rs</a></h2>
<p>The client begins by making sure the user specified a server address at the command line. After printing a message to the terminal, it constructs a hydroflow graph.</p>
<p>Again, we start the hydroflow code defining shared inbound and outbound channels. The code here is simplified compared
to the server because the <code>inbound_chan</code> and <code>outbound_chan</code> are each referenced only once, so they do not require <code>tee</code> or <code>merge</code> operators, respectively (they have been commented out).</p>
<p>The <code>inbound_chan</code> drives a pipeline that prints messages to the screen. </p>
<p>Only the last pipeline is novel for us by now. It uses another new source operator <a href="./surface_ops.gen.html#source_stdin"><code>source_stdin()</code></a>, which does what you might expect: it streams lines of text as they arrive from <code>stdin</code> (i.e. as they are typed into a terminal). It then uses a <code>map</code> to construct an <code>EchoMsg</code> with each line of text and the current timestamp. The result is piped into a sink operator <a href="./surface_ops.gen.html#dest_sink_serde"><code>dest_sink_serde()</code></a>, which sends the message to the server.</p>
<p>The client logic ends by launching the flow graph with <code>flow.run_async().await.unwrap()</code>.</p>
<pre><code class="language-rust ignore">use crate::protocol::EchoMsg;
use crate::Opts;
use chrono::prelude::*;
use hydroflow::hydroflow_syntax;
use hydroflow::util::{UdpSink, UdpStream};
use std::net::SocketAddr;

pub(crate) async fn run_client(outbound: UdpSink, inbound: UdpStream, opts: Opts) {
    // server_addr is required for client
    let server_addr = opts.server_addr.expect(&quot;Client requires a server address&quot;);
    println!(&quot;Client live!&quot;);

    let mut flow = hydroflow_syntax! {
        // Define shared inbound and outbound channels
        inbound_chan = source_stream_serde(inbound)
            // -&gt; tee() // commented out since we only use this once in the client template
        ;
        outbound_chan = // merge() -&gt;  // commented out since we only use this once in the client template
            dest_sink_serde(outbound);

        // Print all messages for debugging purposes
        inbound_chan
            -&gt; for_each(|(m, a): (EchoMsg, SocketAddr)| println!(&quot;{}: Got {:?} from {:?}&quot;, Utc::now(), m, a));

        // take stdin and send to server as an Message::Echo
        source_stdin() -&gt; map(|l| (EchoMsg{ payload: l.unwrap(), ts: Utc::now(), }, server_addr) )
            -&gt; outbound_chan;
    };

    flow.run_async().await.unwrap();
}
</code></pre>
<h2 id="running-the-example"><a class="header" href="#running-the-example">Running the example</a></h2>
<p>As described in the <code>README.md</code> file, we can run the server in one terminal, and the client in another. The server will print the messages it receives, and the client will print the messages it receives back from the server. The client and servers' `--server-addr' arguments need to match or this won't work!</p>
<p>Fire up the server in terminal 1:</p>
<pre><code class="language-console">% cargo run -p hydroflow --example echoserver -- --role server --addr localhost:12347
</code></pre>
<p>Then start the client in terminal 2 and type some messages!</p>
<pre><code class="language-console">% cargo run -p hydroflow --example echoserver -- --role client --server-addr localhost:12347
Listening on 127.0.0.1:54532
Connecting to server at 127.0.0.1:12347
Client live!
This is a test
2022-12-15 05:40:11.258052 UTC: Got Echo { payload: &quot;This is a test&quot;, ts: 2022-12-15T05:40:11.257145Z } from 127.0.0.1:12347
This is the rest
2022-12-15 05:40:14.025216 UTC: Got Echo { payload: &quot;This is the rest&quot;, ts: 2022-12-15T05:40:14.023577Z } from 127.0.0.1:12347
</code></pre>
<p>And have a look back at the server console!</p>
<pre><code class="language-console">Listening on 127.0.0.1:12347
Server live!
2022-12-15 05:40:11.256640 UTC: Got Echo { payload: &quot;This is a test&quot;, ts: 2022-12-15T05:40:11.254207Z } from 127.0.0.1:54532
2022-12-15 05:40:14.023363 UTC: Got Echo { payload: &quot;This is the rest&quot;, ts: 2022-12-15T05:40:14.020897Z } from 127.0.0.1:54532
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networked-services-2-chat-server"><a class="header" href="#networked-services-2-chat-server">Networked Services 2: Chat Server</a></h1>
<blockquote>
<p>In this example we cover:</p>
<ul>
<li>Multiple message types and the <code>demux</code> operator.</li>
<li>A broadcast pattern via the <code>cross_join</code> operator.</li>
<li>One-time bootstrapping pipelines</li>
<li>A &quot;gated buffer&quot; pattern via <code>cross_join</code> with a single-object input.</li>
</ul>
</blockquote>
<p>Our previous <a href="./example_7_echo_server.html">echo server</a> example was admittedly simplistic.  In this example, we'll build something a bit more useful: a simple chat server. We will again have two roles: a <code>Client</code> and a <code>Server</code>. <code>Clients</code> will register their presence with the <code>Server</code>, which maintains a list of clients. Each <code>Client</code> sends messages to the <code>Server</code>, which will then broadcast those messages to all other clients. </p>
<h2 id="mainrs-1"><a class="header" href="#mainrs-1">main.rs</a></h2>
<p>The <code>main.rs</code> file here is very similar to that of the echo server, just with two new command-line arguments: one called <code>name</code> for a &quot;nickname&quot; in the chatroom, and another optional argument <code>graph</code> for printing a dataflow graph if desired. To follow along, you can copy the contents of this file into the <code>src/main.rs</code> file of your template.</p>
<pre><code class="language-rust  ignore">use clap::{Parser, ValueEnum};
use client::run_client;
use hydroflow::tokio;
use hydroflow::util::{bind_udp_bytes, ipv4_resolve};
use server::run_server;
use std::net::SocketAddr;

mod client;
mod protocol;
mod server;

#[derive(Clone, ValueEnum, Debug)]
enum Role {
    Client,
    Server,
}
#[derive(Clone, ValueEnum, Debug)]
enum GraphType {
    Mermaid,
    Dot,
    Json,
}

#[derive(Parser, Debug)]
struct Opts {
    #[clap(long)]
    name: String,
    #[clap(value_enum, long)]
    role: Role,
    #[clap(long, value_parser = ipv4_resolve)]
    client_addr: Option&lt;SocketAddr&gt;,
    #[clap(long, value_parser = ipv4_resolve)]
    server_addr: Option&lt;SocketAddr&gt;,
    #[clap(value_enum, long)]
    graph: Option&lt;GraphType&gt;,
}

#[tokio::main]
async fn main() {
    let opts = Opts::parse();
    // if no addr was provided, we ask the OS to assign a local port by passing in &quot;localhost:0&quot;
    let addr = opts
        .addr
        .unwrap_or_else(|| ipv4_resolve(&quot;localhost:0&quot;).unwrap());

    // allocate `outbound` sink and `inbound` stream
    let (outbound, inbound, addr) = bind_udp_bytes(addr).await;
    println!(&quot;Listening on {:?}&quot;, addr);

    match opts.role {
        Role::Client =&gt; {
            run_client(outbound, inbound, opts).await;
        }
        Role::Server =&gt; {
            run_server(outbound, inbound, opts).await;
        }
    }
}
</code></pre>
<h2 id="protocolrs-1"><a class="header" href="#protocolrs-1">protocol.rs</a></h2>
<p>Our protocol file here expands upon what we saw with the echoserver by defining multiple message types. 
Replace the template contents of <code>src/protocol.rs</code> with the following:</p>
<pre><code class="language-rust ignore">use chrono::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(PartialEq, Eq, Clone, Serialize, Deserialize, Debug)]
pub enum Message {
    ConnectRequest,
    ConnectResponse,
    ChatMsg {
        nickname: String,
        message: String,
        ts: DateTime&lt;Utc&gt;,
    },
}
</code></pre>
<p>Note how we use a single Rust <code>enum</code> to represent all varieties of message types; this allows us to handle <code>Message</code>s of different types with a single  Rust network channel. We will use the <a href="./surface_ops.gen.html#demux"><code>demux</code></a> operator to separate out these different message types on the receiving end. </p>
<p>The <code>ConnectRequest</code> and <code>ConnectResponse</code> messages have no payload; 
the address of the sender and the type of the message will be sufficient information. The <code>ChatMsg</code> message type has a <code>nickname</code> field, a <code>message</code> field, and a <code>ts</code> 
field for the timestamp. Once again we use the <code>chrono</code> crate to represent timestamps.</p>
<h2 id="serverrs-1"><a class="header" href="#serverrs-1">server.rs</a></h2>
<p>The chat server is nearly as simple as the echo server. The main differences are (a) we need to handle multiple message types, 
(b) we need to keep track of the list of clients, and (c) we need to broadcast messages to all clients. </p>
<p>To follow along, replace the contents of <code>src/server.rs</code> with the code below:</p>
<pre><code class="language-rust  ignore">use crate::{GraphType, Opts};
use hydroflow::util::{UdpSink, UdpStream};

use crate::protocol::Message;

use hydroflow::hydroflow_syntax;
use hydroflow::scheduled::graph::Hydroflow;

pub(crate) async fn run_server(outbound: UdpSink, inbound: UdpStream, opts: Opts) {
    println!(&quot;Server live!&quot;);

    let mut df: Hydroflow = hydroflow_syntax! {
        // Define shared inbound and outbound channels
        outbound_chan = merge() -&gt; dest_sink_serde(outbound);
        inbound_chan = source_stream_serde(inbound)
            -&gt;  demux(|(msg, addr), var_args!(clients, msgs, errs)|
                    match msg {
                        Message::ConnectRequest =&gt; clients.give(addr),
                        Message::ChatMsg {..} =&gt; msgs.give(msg),
                        _ =&gt; errs.give(msg),
                    }
                );
        clients = inbound_chan[clients] -&gt; tee();
        inbound_chan[errs] -&gt; for_each(|m| println!(&quot;Received unexpected message type: {:?}&quot;, m));
</code></pre>
<p>After a short prelude, we have the Hydroflow code near the top of <code>run_server()</code>. It begins by defining <code>outbound_chan</code> as a <code>merge</code>d destination sink for network messages. Then we get to the
more interesting <code>inbound_chan</code> definition. </p>
<p>The <code>inbound</code> channel is a source stream that will carry many
types of <code>Message</code>s. We use the <a href="./surface_ops.gen.html#demux"><code>demux</code></a> operator to partition the stream objects into three channels. The <code>clients</code> channel 
will carry the addresses of clients that have connected to the server. The <code>msgs</code> channel will carry the <code>ChatMsg</code> messages that clients send to the server. 
The <code>errs</code> channel will carry any other messages that clients send to the server. </p>
<p>Note the structure of the <code>demux</code> operator: it takes a closure on 
<code>(Message, SocketAddr)</code> pairs, and a variadic tuple (<code>var_args!</code>) of output channel names—in this case <code>clients</code>, <code>msgs</code>, and <code>errs</code>. The closure is basically a big
Rust pattern <a href="https://doc.rust-lang.org/book/ch06-02-match.html"><code>match</code></a>, with one arm for each output channel name given in the variadic tuple. Note 
that the different output channels can have different-typed messages! Note also that we destructure the incoming <code>Message</code> types into tuples of fields. (If we didn't we'd either have to write boilerplate code for each message type in every downstream pipeline, or face Rust's dreaded <a href="https://doc.rust-lang.org/book/ch18-02-refutability.html">refutable pattern</a> error!)</p>
<p>The remainder of the server consists of two independent pipelines, the code to print out the flow graph,
and the code to run the flow graph. To follow along, paste the following into the bottom of your <code>src/server.rs</code> file:</p>
<pre><code class="language-rust  ignore">       // Pipeline 1: Acknowledge client connections
        clients[0] -&gt; map(|addr| (Message::ConnectResponse, addr)) -&gt; [0]outbound_chan;

        // Pipeline 2: Broadcast messages to all clients
        broadcast = cross_join() -&gt; [1]outbound_chan;
        inbound_chan[msgs] -&gt; [0]broadcast;
        clients[1] -&gt; [1]broadcast;
    };

    if let Some(graph) = graph {
        let serde_graph = df
            .meta_graph()
            .expect(&quot;No graph found, maybe failed to parse.&quot;);
        match graph {
            GraphType::Mermaid =&gt; {
                println!(&quot;{}&quot;, serde_graph.to_mermaid());
            }
            GraphType::Dot =&gt; {
                println!(&quot;{}&quot;, serde_graph.to_dot())
            }
            GraphType::Json =&gt; {
                unimplemented!();
                // println!(&quot;{}&quot;, serde_graph.to_json())
            }
        }
    }

    df.run_async().await.unwrap();
}
</code></pre>
<p>The first pipeline is one line long, 
and is responsible for acknowledging requests from <code>clients</code>: it takes the address of the incoming <code>Message::ConnectRequest</code> 
and sends a <code>ConnectResponse</code> back to that address. The second pipeline is responsible for broadcasting 
all chat messages to all clients. This all-to-all pairing corresponds to the notion of a cartesian product
or <a href="./surface_ops.gen.html#cross_join"><code>cross_join</code></a> in Hydroflow. The <code>cross_join</code> operator takes two input 
channels and produces a single output channel with a tuple for each pair of inputs, in this case it produces
<code>(Message, SocketAddr)</code> pairs. Conveniently, that is exactly the structure needed for sending to the <code>outbound_chan</code> sink!
We call the cross-join pipeline <code>broadcast</code> because it effectively broadcasts all messages to all clients.</p>
<p>The mermaid graph for the server is below. The three branches of the <code>demux</code> are very clear toward the top. Note also the <code>tee</code> of the <code>clients</code> channel
for both <code>ClientResponse</code> and broadcasting, and the <code>merge</code> of all outbound messages into <code>dest_sink_serde</code>.</p>
<pre class="mermaid">%%{init: {'theme': 'base', 'themeVariables': {'clusterBkg':'#ddd'}}}%%
flowchart TD
classDef pullClass fill:#02f,color:#fff,stroke:#000
classDef pushClass fill:#ff0,stroke:#000
linkStyle default stroke:#aaa,stroke-width:4px,color:red,font-size:1.5em;
subgraph &quot;sg_1v1 stratum 0&quot;
    7v1[\&quot;(7v1) &lt;tt&gt;map(| addr | (Message :: ConnectResponse, addr))&lt;/tt&gt;&quot;/]:::pullClass
    8v1[\&quot;(8v1) &lt;tt&gt;cross_join()&lt;/tt&gt;&quot;/]:::pullClass
    1v1[\&quot;(1v1) &lt;tt&gt;merge()&lt;/tt&gt;&quot;/]:::pullClass
    2v1[/&quot;(2v1) &lt;tt&gt;dest_sink_serde(outbound)&lt;/tt&gt;&quot;\]:::pushClass
    7v1--0---&gt;1v1
    8v1--1---&gt;1v1
    1v1---&gt;2v1
end
subgraph &quot;sg_2v1 stratum 0&quot;
    3v1[\&quot;(3v1) &lt;tt&gt;source_stream_serde(inbound)&lt;/tt&gt;&quot;/]:::pullClass
    4v1[/&quot;(4v1) &lt;tt&gt;demux(| (msg, addr), var_args! (clients, msgs, errs) | match msg&lt;br&gt;{&lt;br&gt;    Message :: ConnectRequest =&amp;gt; clients.give(addr), Message :: ChatMsg { .. }&lt;br&gt;    =&amp;gt; msgs.give(msg), _ =&amp;gt; errs.give(msg),&lt;br&gt;})&lt;/tt&gt;&quot;\]:::pushClass
    5v1[/&quot;(5v1) &lt;tt&gt;tee()&lt;/tt&gt;&quot;\]:::pushClass
    6v1[/&quot;(6v1) &lt;tt&gt;for_each(| m | println! (&amp;quot;Received unexpected message type: {:?}&amp;quot;, m))&lt;/tt&gt;&quot;\]:::pushClass
    3v1---&gt;4v1
    4v1--clients---&gt;5v1
    4v1--errs---&gt;6v1
end
4v1--msgs---&gt;10v1
5v1--0---&gt;9v1
5v1--1---&gt;11v1
9v1[&quot;(9v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
9v1---&gt;7v1
10v1[&quot;(10v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
10v1--0---&gt;8v1
11v1[&quot;(11v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
11v1--1---&gt;8v1
</pre>
<h2 id="clientrs-1"><a class="header" href="#clientrs-1">client.rs</a></h2>
<p>The chat client is not very different from the echo server client, with two new design patterns:</p>
<ol>
<li>a degenerate <code>source_iter</code> pipeline that runs once 
as a &quot;bootstrap&quot; in the first tick</li>
<li>the use of <code>cross_join</code> as a &quot;gated buffer&quot; to postpone sending messages.</li>
</ol>
<p>We also include a Rust helper routine <code>pretty_print_msg</code> for formatting output.</p>
<p>The prelude of the file is almost the same as the echo server client, with the addition of a crate for 
handling <code>colored</code> text output. This is followed by the <code>pretty_print_msg</code> function, which is fairly self-explanatory. 
To follow along, start by replacing the contents of <code>src/client.rs</code> with the following:</p>
<pre><code class="language-rust ignore">use crate::protocol::Message;
use crate::{GraphType, Opts};
use chrono::prelude::*;
use hydroflow::hydroflow_syntax;
use hydroflow::util::{UdpSink, UdpStream};

use chrono::Utc;
use colored::Colorize;

fn pretty_print_msg(msg: Message) {
    if let Message::ChatMsg {
        nickname,
        message,
        ts,
    } = msg
    {
        println!(
            &quot;{} {}: {}&quot;,
            ts.with_timezone(&amp;Local)
                .format(&quot;%b %-d, %-I:%M:%S&quot;)
                .to_string()
                .truecolor(126, 126, 126)
                .italic(),
            nickname.green().italic(),
            message,
        );
    }
}
</code></pre>
<p>This brings us to the <code>run_client</code> function. As in <code>run_server</code> we begin by ensuring the server address 
is supplied. We then have the hydroflow code starting with a standard pattern of a <code>merge</code>d <code>outbound_chan</code>, 
and a <code>demux</code>ed <code>inbound_chan</code>. The client handles only two inbound <code>Message</code> types: <code>Message::ConnectResponse</code> and <code>Message::ChatMsg</code>.</p>
<p>Paste the following to the bottom of <code>src/client.rs</code>:</p>
<pre><code class="language-rust ignore">pub(crate) async fn run_client(outbound: UdpSink, inbound: UdpStream, opts: Opts) {
    // server_addr is required for client
    let server_addr = opts.server_addr.expect(&quot;Client requires a server address&quot;);
    println!(&quot;Client live!&quot;);

    let mut hf = hydroflow_syntax! {
        // set up channels
        outbound_chan = merge() -&gt; dest_sink_serde(outbound);
        inbound_chan = source_stream_serde(inbound) -&gt; map(|(m, _)| m)
            -&gt;  demux(|m, var_args!(acks, msgs, errs)|
                    match m {
                        Message::ConnectResponse =&gt; acks.give(m),
                        Message::ChatMsg {..} =&gt; msgs.give(m),
                        _ =&gt; errs.give(m),
                    }
                );
        inbound_chan[errs] -&gt; for_each(|m| println!(&quot;Received unexpected message type: {:?}&quot;, m));
</code></pre>
<p>The core logic of the client consists of three dataflow pipelines shown below. Paste this into the
bottom of your <code>src/client.rs</code> file.</p>
<pre><code class="language-rust ignore">        // send a single connection request on startup
        source_iter([()]) -&gt; map(|_m| (Message::ConnectRequest, server_addr)) -&gt; [0]outbound_chan;

        // take stdin and send to server as a msg
        // the cross_join serves to buffer msgs until the connection request is acked
        msg_send = cross_join() -&gt; map(|(msg, _)| (msg, server_addr)) -&gt; [1]outbound_chan;
        lines = source_stdin()
          -&gt; map(|l| Message::ChatMsg {
                    nickname: opts.name.clone(),
                    message: l.unwrap(),
                    ts: Utc::now()})
          -&gt; [0]msg_send;
        inbound_chan[acks] -&gt; [1]msg_send;

        // receive and print messages
        inbound_chan[msgs] -&gt; for_each(pretty_print_msg);
    };
</code></pre>
<ol>
<li>
<p>The first pipeline is the &quot;bootstrap&quot; alluded to above.
It starts with <code>source_iter</code> operator that emits a single, opaque &quot;unit&quot; (<code>()</code>) value. This value is available when the client begins, which means 
this pipeline runs once, immediately on startup, and generates a single <code>ConnectRequest</code> message which is sent to the server.</p>
</li>
<li>
<p>The second pipeline reads from <code>source_stdin</code> and sends messages to the server. It differs from our echo-server example in the use of a <code>cross_join</code>
with <code>inbound_chan[acks]</code>. This cross-join is similar to that of the server: it forms pairs between all messages and all servers that send a <code>ConnectResponse</code> ack. 
In principle this means that the client is broadcasting each message to all servers.
In practice, however, the client establishes at most one connection to a server. Hence over time, this pipeline starts with zero <code>ConnectResponse</code>s and is sending no messages; 
subsequently it receives a single <code>ConnectResponse</code> and starts sending messages. The <code>cross_join</code> is thus effectively a buffer for messages, and a &quot;gate&quot; on that buffer that opens 
when the client receives its sole <code>ConnectResponse</code>.</p>
</li>
<li>
<p>The final pipeline simply pretty-prints the messages received from the server.</p>
</li>
</ol>
<p>Finish up the file by pasting the code below for optionally generating the graph and running the flow:</p>
<pre><code class="language-rust ignore">    // optionally print the dataflow graph
    if let Some(graph) = opts.graph {
        let serde_graph = hf
            .meta_graph()
            .expect(&quot;No graph found, maybe failed to parse.&quot;);
        match graph {
            GraphType::Mermaid =&gt; {
                println!(&quot;{}&quot;, serde_graph.to_mermaid());
            }
            GraphType::Dot =&gt; {
                println!(&quot;{}&quot;, serde_graph.to_dot())
            }
            GraphType::Json =&gt; {
                unimplemented!();
            }
        }
    }

    hf.run_async().await.unwrap();
}
</code></pre>
<p>The client's mermaid graph looks a bit different than the server's, mostly because it routes some data to
the screen rather than to an outbound network channel.</p>
<pre class="mermaid">%%{init: {'theme': 'base', 'themeVariables': {'clusterBkg':'#ddd'}}}%%
flowchart TD
classDef pullClass fill:#02f,color:#fff,stroke:#000
classDef pushClass fill:#ff0,stroke:#000
linkStyle default stroke:#aaa,stroke-width:4px,color:red,font-size:1.5em;
subgraph &quot;sg_1v1 stratum 0&quot;
    7v1[\&quot;(7v1) &lt;tt&gt;source_iter([()])&lt;/tt&gt;&quot;/]:::pullClass
    8v1[\&quot;(8v1) &lt;tt&gt;map(| _m | (Message :: ConnectRequest, server_addr))&lt;/tt&gt;&quot;/]:::pullClass
    11v1[\&quot;(11v1) &lt;tt&gt;source_stdin()&lt;/tt&gt;&quot;/]:::pullClass
    12v1[\&quot;(12v1) &lt;tt&gt;map(| l | Message :: ChatMsg&lt;br&gt;{ nickname : opts.name.clone(), message : l.unwrap(), ts : Utc :: now() })&lt;/tt&gt;&quot;/]:::pullClass
    9v1[\&quot;(9v1) &lt;tt&gt;cross_join()&lt;/tt&gt;&quot;/]:::pullClass
    10v1[\&quot;(10v1) &lt;tt&gt;map(| (msg, _) | (msg, server_addr))&lt;/tt&gt;&quot;/]:::pullClass
    1v1[\&quot;(1v1) &lt;tt&gt;merge()&lt;/tt&gt;&quot;/]:::pullClass
    2v1[/&quot;(2v1) &lt;tt&gt;dest_sink_serde(outbound)&lt;/tt&gt;&quot;\]:::pushClass
    7v1---&gt;8v1
    8v1--0---&gt;1v1
    11v1---&gt;12v1
    12v1--0---&gt;9v1
    9v1---&gt;10v1
    10v1--1---&gt;1v1
    1v1---&gt;2v1
end
subgraph &quot;sg_2v1 stratum 0&quot;
    3v1[\&quot;(3v1) &lt;tt&gt;source_stream_serde(inbound)&lt;/tt&gt;&quot;/]:::pullClass
    4v1[/&quot;(4v1) &lt;tt&gt;map(| (m, _) | m)&lt;/tt&gt;&quot;\]:::pushClass
    5v1[/&quot;(5v1) &lt;tt&gt;demux(| m, var_args! (acks, msgs, errs) | match m&lt;br&gt;{&lt;br&gt;    Message :: ConnectResponse =&amp;gt; acks.give(m), Message :: ChatMsg { .. } =&amp;gt;&lt;br&gt;    msgs.give(m), _ =&amp;gt; errs.give(m),&lt;br&gt;})&lt;/tt&gt;&quot;\]:::pushClass
    6v1[/&quot;(6v1) &lt;tt&gt;for_each(| m | println! (&amp;quot;Received unexpected message type: {:?}&amp;quot;, m))&lt;/tt&gt;&quot;\]:::pushClass
    13v1[/&quot;(13v1) &lt;tt&gt;for_each(pretty_print_msg)&lt;/tt&gt;&quot;\]:::pushClass
    3v1---&gt;4v1
    4v1---&gt;5v1
    5v1--errs---&gt;6v1
    5v1--msgs---&gt;13v1
end
5v1--acks---&gt;14v1
14v1[&quot;(14v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
14v1--1---&gt;9v1
</pre>
<h2 id="running-the-example-1"><a class="header" href="#running-the-example-1">Running the example</a></h2>
<p>As described in <code>hydroflow/hydroflow/example/chat/README.md</code>, we can run the server in one terminal, and run clients in additional terminals.
The client and server need to agree on <code>server-addr</code> or this won't work!</p>
<p>Fire up the server in terminal 1:</p>
<pre><code class="language-console">% cargo run -p hydroflow --example chat -- --name &quot;_&quot; --role server --server-addr 127.0.0.1:12347
</code></pre>
<p>Start client &quot;alice&quot; in terminal 2 and type some messages, and you'll see them 
echoed back to you. This will appear in colored fonts in most terminals
(but unfortunately not in this markdown-based book!)</p>
<pre><code class="language-console">% cargo run -p hydroflow --example chat -- --name &quot;alice&quot; --role client --server-addr 127.0.0.1:12347
Listening on 127.0.0.1:50617
Connecting to server at 127.0.0.1:12347
Client live!
Hello (hello hello) ... is there anybody in here?
Dec 13, 12:04:34 alice: Hello (hello hello) ... is there anybody in here?
Just nod if you can hear me.
Dec 13, 12:04:58 alice: Just nod if you can hear me.
Is there anyone home?
Dec 13, 12:05:01 alice: Is there anyone home?
</code></pre>
<p>Now start client &quot;bob&quot; in terminal 3, and notice how he instantly receives the backlog of Alice's messages from the server's <code>cross_join</code>. 
(The messages may not be printed in the same order as they were timestamped! The <code>cross_join</code> operator is not guaranteed to preserve order, nor
is the udp network. Fixing these issues requires extra client logic that we leave as an exercise to the reader.)</p>
<pre><code class="language-console">% cargo run -p hydroflow --example chat -- --name &quot;bob&quot; --role client --server-addr 127.0.0.1:12347
Listening on 127.0.0.1:63018
Connecting to server at 127.0.0.1:12347
Client live!
Dec 13, 12:05:01 alice: Is there anyone home?
Dec 13, 12:04:58 alice: Just nod if you can hear me.
Dec 13, 12:04:34 alice: Hello (hello hello) ... is there anybody in here?
</code></pre>
<p>Now in terminal 3, Bob can respond:</p>
<pre><code class="language-console">*nods*
Dec 13, 12:05:05 bob: *nods*
</code></pre>
<p>and if we go back to terminal 2 we can see that Alice gets the message too:</p>
<pre><code class="language-console">Dec 13, 12:05:05 bob: *nods*
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hydroflow-surface-syntax"><a class="header" href="#hydroflow-surface-syntax">Hydroflow Surface Syntax</a></h1>
<p>The natural way to write a Hydroflow program is using the <em>Surface Syntax</em> documented here. 
It is a chained <code>Iterator</code>-style syntax of operators built into Hydroflow that should be sufficient
for most uses. If you want lower-level access you can work with the <code>Core API</code> documented in the <a href="./architecture.html">Architecture</a> section.</p>
<p>In this chapter we go over the syntax piece by piece: how to <a href="./surface_embedding.html">embed surface syntax in Rust</a> and how to specify <a href="./surface_flows.html"><em>flows</em></a>, which consist of <a href="./surface_data.html"><em>data sources</em></a> flowing through <a href="./surface_ops.gen.html"><em>operators</em></a>.</p>
<!-- TODO(mingwei): In the [Hydroflow Types](surface_types.md) chapter we dive into the details of the data types that pass through flows. -->
<p>As a teaser, here is a Rust/Hydroflow &quot;HELLO WORLD&quot; program:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hydroflow::hydroflow_syntax;

pub fn test_hello_world() {
    let mut df = hydroflow_syntax! {
        source_iter(vec![&quot;hello&quot;, &quot;world&quot;])
            -&gt; map(|x| x.to_uppercase()) -&gt; for_each(|x| println!(&quot;{}&quot;, x));
    };
    df.run_available();
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedding-a-flow-in-rust"><a class="header" href="#embedding-a-flow-in-rust">Embedding a Flow in Rust</a></h1>
<p>Hydroflow's surface syntax is typically used within a Rust program. (An interactive client and/or external language bindings are TBD.)</p>
<p>The surface syntax is embedded into Rust via a macro as follows</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hydroflow::hydroflow_syntax;

pub fn example() {
    let mut flow = hydroflow_syntax! {
        // Hydroflow Surface Syntax goes here
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>The resulting <code>flow</code> object is of type <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html"><code>Hydroflow</code></a>.</p>
<!-- TODO(mingwei): see the documentation on the
[Hydroflow Object](./hydroflow_object.md) for details on how to use the result. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-syntax"><a class="header" href="#flow-syntax">Flow Syntax</a></h1>
<p>Flows consist of named <em>operators</em> that are connected via flow <em>edges</em> denoted by <code>-&gt;</code>. The example below
uses the <a href="./surface_ops.gen.html#source_iter"><code>source_iter</code></a> operator to generate two strings from a Rust <code>vec</code>, the
<a href="./surface_ops.gen.html#map"><code>map</code></a> operator to apply some Rust code to uppercase each string, and the <a href="./surface_ops.gen.html#for_each"><code>for_each</code></a>
operator to print each string to stdout.</p>
<pre><code class="language-rust ignore">source_iter(vec![&quot;Hello&quot;, &quot;world&quot;])
    -&gt; map(|x| x.to_uppercase()) -&gt; for_each(|x| println!(&quot;{}&quot;, x));
</code></pre>
<p>Flows can be assigned to variable names for convenience. E.g, the above can be rewritten as follows:</p>
<pre><code class="language-rust ignore">source_iter(vec![&quot;Hello&quot;, &quot;world&quot;]) -&gt; upper_print;
upper_print = map(|x| x.to_uppercase()) -&gt; for_each(|x| println!(&quot;{}&quot;, x));
</code></pre>
<p>Note that the order of the statements (lines) doesn't matter. In this example, <code>upper_print</code> is
referenced before it is assigned, and that is completely OK and better matches the flow of
data, making the program more understandable.</p>
<h2 id="operators-with-multiple-ports"><a class="header" href="#operators-with-multiple-ports">Operators with Multiple Ports</a></h2>
<p>Some operators have more than one input <em>port</em> that can be referenced by <code>-&gt;</code>. For example <a href="./surface_ops.gen.html#merge"><code>merge</code></a>
merges the contents of many flows, so it can have an abitrary number of input ports. Some operators have multiple outputs, notably <a href="./surface_ops.gen.html#tee"><code>tee</code></a>,
which has an arbitrary number of outputs.</p>
<p>In the syntax, we optionally distinguish input ports via an <em>indexing prefix</em> number
in square brackets before the name (e.g. <code>[0]my_join</code> and <code>[1]my_join</code>). We
can distinguish output ports by an <em>indexing suffix</em> (e.g. <code>my_tee[0]</code>).</p>
<p>Here is an example that tees one flow into two, handles each separately, and then merges them to print out the contents in both lowercase and uppercase:</p>
<pre><code class="language-rust ignore">my_tee = source_iter(vec![&quot;Hello&quot;, &quot;world&quot;]) -&gt; tee();
my_tee -&gt; map(|x| x.to_uppercase()) -&gt; my_merge;
my_tee -&gt; map(|x| x.to_lowercase()) -&gt; my_merge;
my_merge = merge() -&gt; for_each(|x| println!(&quot;{}&quot;, x));
</code></pre>
<p><code>merge()</code> and <code>tee()</code> treat all their input/outputs the same, so we omit the indexing.</p>
<p>Here is a visualization of the flow that was generated:</p>
<pre class="mermaid">%%{init:{'theme':'base','themeVariables':{'clusterBkg':'#ddd','clusterBorder':'#888'}}}%%
flowchart TD
classDef pullClass fill:#02f,color:#fff,stroke:#000
classDef pushClass fill:#ff0,stroke:#000
linkStyle default stroke:#aaa,stroke-width:4px,color:red,font-size:1.5em;
subgraph sg_1v1 [&quot;sg_1v1 stratum 0&quot;]
    1v1[\&quot;(1v1) &lt;tt&gt;source_iter(vec! [&amp;quot;Hello&amp;quot;, &amp;quot;world&amp;quot;])&lt;/tt&gt;&quot;/]:::pullClass
    2v1[/&quot;(2v1) &lt;tt&gt;tee()&lt;/tt&gt;&quot;\]:::pushClass
    1v1---&gt;2v1
    subgraph sg_1v1_var_my_tee [&quot;var &lt;tt&gt;my_tee&lt;/tt&gt;&quot;]
        1v1
        2v1
    end
end
subgraph sg_2v1 [&quot;sg_2v1 stratum 0&quot;]
    3v1[\&quot;(3v1) &lt;tt&gt;map(| x : &amp;amp; str | x.to_uppercase())&lt;/tt&gt;&quot;/]:::pullClass
    4v1[\&quot;(4v1) &lt;tt&gt;map(| x : &amp;amp; str | x.to_lowercase())&lt;/tt&gt;&quot;/]:::pullClass
    5v1[\&quot;(5v1) &lt;tt&gt;merge()&lt;/tt&gt;&quot;/]:::pullClass
    6v1[/&quot;(6v1) &lt;tt&gt;for_each(| x | println! (&amp;quot;{}&amp;quot;, x))&lt;/tt&gt;&quot;\]:::pushClass
    3v1--0---&gt;5v1
    4v1--1---&gt;5v1
    5v1---&gt;6v1
    subgraph sg_2v1_var_my_merge [&quot;var &lt;tt&gt;my_merge&lt;/tt&gt;&quot;]
        5v1
        6v1
    end
end
2v1--0---&gt;7v1
2v1--1---&gt;8v1
7v1[&quot;(7v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
7v1---&gt;3v1
8v1[&quot;(8v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
8v1---&gt;4v1
</pre>
<p>Hydroflow compiled this flow into two subgraphs called <em>compiled components</em>, connected by <em>handoffs</em>. You can ignore
these details unless you are interested in low-level performance tuning; they are explained in the discussion
of <a href="./in-out_trees.html">in-out trees</a>.</p>
<h3 id="a-note-on-assigning-flows-with-multiple-ports"><a class="header" href="#a-note-on-assigning-flows-with-multiple-ports">A note on assigning flows with multiple ports</a></h3>
<blockquote>
<p><em>TODO</em>: <em>Need to document the port numbers for variables assigned to tree- or dag-shaped flows</em></p>
</blockquote>
<h2 id="the-context-object"><a class="header" href="#the-context-object">The <code>context</code> object</a></h2>
<p>Closures inside surface syntax operators have access to a special <code>context</code> object which provides
access to scheduling, timing, and state APIs. The object is accessible as a shared reference
(<code>&amp;Context</code>) via the special name <code>context</code>.
<a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/context/struct.Context.html">Here is the full API documentation for <code>Context</code></a>.</p>
<pre><code class="language-rust ignore">source_iter([()])
    -&gt; for_each(|()| println!(&quot;Current tick: {}, stratum: {}&quot;, context.current_tick(), context.current_stratum()));
// Current tick: 0, stratum: 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-sources-and-sinks-in-rust"><a class="header" href="#data-sources-and-sinks-in-rust">Data Sources and Sinks in Rust</a></h1>
<p>Any useful flow requires us to define sources of data, either generated computationally or received from 
and outside environment via I/O.</p>
<h2 id="source_iter"><a class="header" href="#source_iter"><code>source_iter</code></a></h2>
<p>A flow can receive data from a Rust collection object via the <code>source_iter</code> operator, which takes the 
iterable collection as an argument and passes the items down the flow. 
For example, here we iterate through a vector of <code>usize</code> items and push them down the flow:</p>
<pre><code class="language-rust ignore">    source_iter(vec![0, 1]) -&gt; ...
</code></pre>
<p>The Hello, World example above uses this construct.</p>
<h2 id="source_stream"><a class="header" href="#source_stream"><code>source_stream</code></a></h2>
<p>More commonly, a flow should handle external data coming in asynchronously from a <a href="https://tokio.rs/tokio/tutorial"><em>Tokio</em> runtime</a>.
One way to do this is with <em>channels</em> that allow Rust code to send data into the Hydroflow inputs.
The code below creates a channel for data of (Rust) type <code>(usize, usize)</code>:</p>
<pre><code class="language-rust ignore">    let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;(usize, usize)&gt;();
</code></pre>
<p>Under the hood this uses <a href="https://docs.rs/tokio/latest/tokio/sync/mpsc/fn.unbounded_channel.html">Tokio unbounded channels</a>.
Now in Rust we can now push data into the channel. E.g. for testing we can do
it explicitly as follows:</p>
<pre><code class="language-rust ignore">    input_send.send((0, 1)).unwrap()
</code></pre>
<p>And in our Hydroflow syntax we can receive the data from the channel using the <code>source_stream</code> syntax and
pass it along a flow:</p>
<pre><code class="language-rust ignore">    source_stream(input_recv) -&gt; ...
</code></pre>
<p>To put this together, let's revisit our Hello, World example from above with data sent 
in from outside the flow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use hydroflow::hydroflow_syntax;
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;&amp;str&gt;();
let mut flow = hydroflow_syntax! {
    source_stream(input_recv) -&gt; map(|x| x.to_uppercase())
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
};
input_send.send(&quot;Hello&quot;).unwrap();
input_send.send(&quot;World&quot;).unwrap();
flow.run_available();
<span class="boring">}
</span></code></pre></pre>
<p>TODO: add source_stream_serde</p>
<div style="break-before: page; page-break-before: always;"></div><!-- GENERATED "hydroflow_macro/build.rs" -->
<h1 id="hydroflows-built-in-operators"><a class="header" href="#hydroflows-built-in-operators">Hydroflow's Built-in Operators</a></h1>
<p>In our previous examples we made use of some of Hydroflow's built-in operators.
Here we document each operators in more detail. Most of these operators
are based on the Rust equivalents for iterators; see the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Rust documentation</a>.</p>
<h2 id="anti_join"><a class="header" href="#anti_join"><code>anti_join</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; [&lt;input_port&gt;]anti_join() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Input port names: <code>pos</code> (streaming), <code>neg</code> (blocking)</p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/anti_join.rs" -->
<blockquote>
<p>2 input streams the first of type (K, T), the second of type K,
with output type (K, T)</p>
</blockquote>
<p>For a given tick, computes the anti-join of the items in the input
streams, returning items in the <code>pos</code> input that do not have matching keys
in the <code>neg</code> input.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print (&quot;elephant&quot;, 3)
source_iter(vec![(&quot;dog&quot;, 1), (&quot;cat&quot;, 2), (&quot;elephant&quot;, 3)]) -&gt; [pos]diff;
source_iter(vec![&quot;dog&quot;, &quot;cat&quot;, &quot;gorilla&quot;]) -&gt; [neg]diff;
diff = anti_join() -&gt; for_each(|v: (_, _)| println!(&quot;{}, {}&quot;, v.0, v.1));
// elephant 3
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="batch"><a class="header" href="#batch"><code>batch</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; batch(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/batch.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: The receive end of a tokio channel that signals when to release the batch downstream.</p>
</blockquote>
<p>Given a <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a>
created in Rust code, <code>batch</code>
is passed the receive end of the channel and when receiving any element
will pass through all received inputs to the output unchanged.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let (tx, rx) = hydroflow::util::unbounded_channel::&lt;()&gt;();

    // Will print 0, 1, 2, 3, 4 each on a new line just once.
    let mut df = hydroflow::hydroflow_syntax! {
        repeat_iter(0..5) -&gt; batch(rx) -&gt; for_each(|x| { println!(&quot;{x}&quot;); });
    };

    tx.send(()).unwrap();

    df.run_available();
<span class="boring">}
</span></code></pre></pre>
<h2 id="cross_join"><a class="header" href="#cross_join"><code>cross_join</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; [&lt;input_port&gt;]cross_join() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Input port names: <code>0</code> (streaming), <code>1</code> (streaming)</p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/cross_join.rs" -->
<blockquote>
<p>2 input streams of type S and T, 1 output stream of type (S, T)</p>
</blockquote>
<p>Forms the cross-join (Cartesian product) of the items in the input streams, returning all
tupled pairs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print all 4 pairs of emotion and animal
source_iter(vec![&quot;happy&quot;, &quot;sad&quot;]) -&gt; [0]my_join;
source_iter(vec![&quot;dog&quot;, &quot;cat&quot;]) -&gt; [1]my_join;
my_join = cross_join() -&gt; for_each(|(v1, v2)| println!(&quot;({}, {})&quot;, v1, v2));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>cross_join</code> can also be provided with one or two generic lifetime persistence arguments
in the same was as <a href="surface_ops.gen.html#join"><code>join</code></a>, see <a href="surface_ops.gen.html#join"><code>join</code>'s documentation</a> for more info.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;&amp;str&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    my_join = cross_join::&lt;'tick&gt;();
    source_iter([&quot;hello&quot;, &quot;bye&quot;]) -&gt; [0]my_join;
    source_stream(input_recv) -&gt; [1]my_join;
    my_join -&gt; for_each(|(s, t)| println!(&quot;({}, {})&quot;, s, t));
};
input_send.send(&quot;oakland&quot;).unwrap();
flow.run_tick();
input_send.send(&quot;san francisco&quot;).unwrap();
flow.run_tick();
<span class="boring">}
</span></code></pre></pre>
<p>Prints only <code>&quot;(hello, oakland)&quot;</code> and <code>&quot;(bye, oakland)&quot;</code>. The <code>source_iter</code> is only included in
the first tick, then forgotten.</p>
<h2 id="demux"><a class="header" href="#demux"><code>demux</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; demux(A)[&lt;output_port&gt;] -&gt;</code></td><td><span title="at least 2">at least 2</span></td><td>Streaming</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Output port names: Variadic, as specified in arguments.</p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/demux.rs" -->
<blockquote>
<p>Arguments: A Rust closure, the first argument is a received item and the
second argument is a variadic <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/macro.var_args.html"><code>var_args!</code> tuple list</a>
where each item name is an output port.</p>
</blockquote>
<p>Takes the input stream and allows the user to determine what elemnt(s) to
deliver to any number of output streams.</p>
<blockquote>
<p>Note: Downstream operators may need explicit type annotations.</p>
</blockquote>
<blockquote>
<p>Note: The <a href="https://hydro-project.github.io/hydroflow/doc/pusherator/trait.Pusherator.html"><code>Pusherator</code></a>
trait is automatically imported to enable the <a href="https://hydro-project.github.io/hydroflow/doc/pusherator/trait.Pusherator.html#tymethod.give"><code>.give(...)</code> method</a>.</p>
</blockquote>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>my_demux = source_iter(1..=100) -&gt; demux(|v, var_args!(fzbz, fizz, buzz, vals)|
    match (v % 3, v % 5) {
        (0, 0) =&gt; fzbz.give(v),
        (0, _) =&gt; fizz.give(v),
        (_, 0) =&gt; buzz.give(v),
        (_, _) =&gt; vals.give(v),
    }
);
my_demux[fzbz] -&gt; for_each(|v| println!(&quot;{}: fizzbuzz&quot;, v));
my_demux[fizz] -&gt; for_each(|v| println!(&quot;{}: fizz&quot;, v));
my_demux[buzz] -&gt; for_each(|v| println!(&quot;{}: buzz&quot;, v));
my_demux[vals] -&gt; for_each(|v| println!(&quot;{}&quot;, v));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="dest_sink"><a class="header" href="#dest_sink"><code>dest_sink</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; dest_sink(A)</code></td><td><span title="exactly 0">exactly 0</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/dest_sink.rs" -->
<blockquote>
<p>Arguments: An <a href="https://docs.rs/futures/latest/futures/sink/trait.Sink.html">async <code>Sink</code></a>.</p>
</blockquote>
<p>Consumes items by sending them to an <a href="https://docs.rs/futures/latest/futures/sink/trait.Sink.html">async <code>Sink</code></a>.
A <code>Sink</code> is a thing into which values can be sent, asynchronously. For example, sending items
into a bounded channel.</p>
<p>Note this operator must be used within a Tokio runtime.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[tokio::main(flavor = &quot;current_thread&quot;)]
</span><span class="boring">async fn main() {
</span>// In this example we use a _bounded_ channel for our `Sink`. This is for demonstration only,
// instead you should use [`hydroflow::util::unbounded_channel`]. A bounded channel results in
// `Hydroflow` buffering items internally instead of within the channel. (We can't use
// unbounded here since unbounded channels are synchonous to write to and therefore not
// `Sink`s.)
let (send, recv) = tokio::sync::mpsc::channel::&lt;usize&gt;(5);
// `PollSender` adapts the send half of the bounded channel into a `Sink`.
let send = tokio_util::sync::PollSender::new(send);

let mut flow = hydroflow::hydroflow_syntax! {
    source_iter(0..10) -&gt; dest_sink(send);
};
// Call `run_async()` to allow async events to propegate, run for one second.
tokio::time::timeout(std::time::Duration::from_secs(1), flow.run_async())
    .await
    .expect_err(&quot;Expected time out&quot;);

let mut recv = tokio_stream::wrappers::ReceiverStream::new(recv);
// Only 5 elements received due to buffer size.
// (Note that if we were using a multi-threaded executor instead of `current_thread` it would
// be possible for more items to be added as they're removed, resulting in &gt;5 collected.)
let out: Vec&lt;_&gt; = hydroflow::util::ready_iter(&amp;mut recv).collect();
assert_eq!(&amp;[0, 1, 2, 3, 4], &amp;*out);
<span class="boring">}
</span></code></pre></pre>
<p><code>Sink</code> is different from <a href="https://docs.rs/futures/latest/futures/io/trait.AsyncWrite.html"><code>AsyncWrite</code></a>.
Instead of discrete values we send arbitrary streams of bytes into an <code>AsyncWrite</code> value. For
example, writings a stream of bytes to a file, a socket, or stdout.</p>
<p>To handle those situations we can use a codec from <a href="crate::tokio_util::codec"><code>tokio_util::codec</code></a>.
These specify ways in which the byte stream is broken into individual items, such as with
newlines or with length delineation.</p>
<p>If we only want to write a stream of bytes without delineation we can use the <a href="crate::tokio_util::codec::BytesCodec"><code>BytesCodec</code></a>.</p>
<p>In this example we use a <a href="crate::tokio::io::duplex"><code>duplex</code></a> as our <code>AsyncWrite</code> with a
<code>BytesCodec</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span>use bytes::Bytes;
use tokio::io::AsyncReadExt;

// Like a channel, but for a stream of bytes instead of discrete objects.
let (asyncwrite, mut asyncread) = tokio::io::duplex(256);
// Now instead handle discrete byte strings by length-encoding them.
let sink = tokio_util::codec::FramedWrite::new(asyncwrite, tokio_util::codec::BytesCodec::new());

let mut flow = hydroflow::hydroflow_syntax! {
    source_iter([
        Bytes::from_static(b&quot;hello&quot;),
        Bytes::from_static(b&quot;world&quot;),
    ]) -&gt; dest_sink(sink);
};
tokio::time::timeout(std::time::Duration::from_secs(1), flow.run_async())
    .await
    .expect_err(&quot;Expected time out&quot;);

let mut buf = Vec::&lt;u8&gt;::new();
asyncread.read_buf(&amp;mut buf).await.unwrap();
assert_eq!(b&quot;helloworld&quot;, &amp;*buf);
<span class="boring">}
</span></code></pre></pre>
<h2 id="dest_sink_serde"><a class="header" href="#dest_sink_serde"><code>dest_sink_serde</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; dest_sink_serde(A)</code></td><td><span title="exactly 0">exactly 0</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/dest_sink_serde.rs" -->
<blockquote>
<p>Arguments: A <a href="https://docs.rs/futures/latest/futures/sink/trait.Sink.html">serializing async <code>Sink</code></a>.</p>
</blockquote>
<p>Consumes (payload, addr) pairs by serializing the payload and sending the resulting pair to an <a href="https://docs.rs/futures/latest/futures/sink/trait.Sink.html">async <code>Sink</code></a>.</p>
<p>Note this operator must be used within a Tokio runtime.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn serde_out() {
    let addr = hydroflow::util::ipv4_resolve(&quot;localhost:9000&quot;.into()).unwrap();
    let (outbound, inbound, _) = hydroflow::util::bind_udp_bytes(addr).await;
    let remote = hydroflow::util::ipv4_resolve(&quot;localhost:9001&quot;.into()).unwrap();
    let mut flow = hydroflow::hydroflow_syntax! {
        source_iter(vec![(&quot;hello&quot;.to_string(), 1), (&quot;world&quot;.to_string(), 2)])
            -&gt; map (|m| (m, remote)) -&gt; dest_sink_serde(outbound);
    };
    flow.run_available();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="difference"><a class="header" href="#difference"><code>difference</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; [&lt;input_port&gt;]difference() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Input port names: <code>pos</code> (streaming), <code>neg</code> (blocking)</p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/difference.rs" -->
<blockquote>
<p>2 input streams of the same type T, 1 output stream of type T</p>
</blockquote>
<p>For a given tick, forms the set difference of the items in the input
streams, returning items in the <code>pos</code> input that are not found in the
<code>neg</code> input.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print &quot;elephant&quot;
source_iter(vec![&quot;dog&quot;, &quot;cat&quot;, &quot;elephant&quot;]) -&gt; [pos]diff;
source_iter(vec![&quot;dog&quot;, &quot;cat&quot;, &quot;gorilla&quot;]) -&gt; [neg]diff;
diff = difference() -&gt; for_each(|v| println!(&quot;{}&quot;, v));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="filter"><a class="header" href="#filter"><code>filter</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; filter(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/filter.rs" -->
<p>Filter outputs a subsequence of the items it receives at its input, according to a
Rust boolean closure passed in as an argument.</p>
<p>The closure receives a reference <code>&amp;T</code> rather than an owned value <code>T</code> because filtering does
not modify or take ownership of the values. If you need to modify the values while filtering
use <a href="surface_ops.gen.html#filter_map"><code>filter_map</code></a> instead.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; filter(|x| x.starts_with('w'))
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="filter_map"><a class="header" href="#filter_map"><code>filter_map</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; filter_map(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/filter_map.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<p>An operator that both filters and maps. It yields only the items for which the supplied closure returns <code>Some(value)</code>.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter(vec![&quot;1&quot;, &quot;hello&quot;, &quot;world&quot;, &quot;2&quot;]) -&gt; filter_map(|s| s.parse().ok())
    -&gt; for_each(|x: usize| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="flat_map"><a class="header" href="#flat_map"><code>flat_map</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; flat_map(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/flat_map.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: A Rust closure that handles an iterator</p>
</blockquote>
<p>For each item <code>i</code> passed in, treat <code>i</code> as an iterator and map the closure to that
iterator to produce items one by one. The type of the input items must be iterable.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print out each character of each word on a separate line
source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; flat_map(|x| x.chars())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="flatten"><a class="header" href="#flatten"><code>flatten</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; flatten() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/flatten.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<p>For each item <code>i</code> passed in, treat <code>i</code> as an iterator and produce its items one by one.
The type of the input items must be iterable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print the numbers 1-6 without any nesting
source_iter(vec![[1, 2], [3, 4], [5, 6]]) -&gt; flatten()
-&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="fold"><a class="header" href="#fold"><code>fold</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; fold(A, B) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/fold.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: an initial value, and a closure which itself takes two arguments:
an 'accumulator', and an element. The closure returns the value that the accumulator should have for the next iteration.</p>
</blockquote>
<p>Akin to Rust's built-in fold operator. Folds every element into an accumulator by applying a closure,
returning the final result.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<p><code>fold</code> can also be provided with one generic lifetime persistence argument, either
<code>'tick</code> or <code>'static</code>, to specify how data persists. With <code>'tick</code>, values will only be collected
within the same tick. With <code>'static</code>, values will be remembered across ticks and will be
aggregated with pairs arriving in later ticks. When not explicitly specified persistence
defaults to <code>'static</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print `Reassembled vector [1,2,3,4,5]`
source_iter([1,2,3,4,5])
    -&gt; fold::&lt;'tick&gt;(Vec::new(), |mut accum, elem| {
        accum.push(elem);
        accum
    })
    -&gt; for_each(|e| println!(&quot;Ressembled vector {:?}&quot;, e));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="for_each"><a class="header" href="#for_each"><code>for_each</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; for_each(A)</code></td><td><span title="exactly 0">exactly 0</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/for_each.rs" -->
<blockquote>
<p>1 input stream, 0 output streams</p>
</blockquote>
<blockquote>
<p>Arguments: a Rust closure</p>
</blockquote>
<p>Iterates through a stream passing each element to the closure in the
argument.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>    source_iter(vec![&quot;Hello&quot;, &quot;World&quot;])
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="group_by"><a class="header" href="#group_by"><code>group_by</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; group_by(A, B) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/group_by.rs" -->
<blockquote>
<p>1 input stream of type (K,V1), 1 output stream of type (K,V2).
The output will have one tuple for each distinct K, with an accumulated value of type V2.</p>
</blockquote>
<blockquote>
<p>Arguments: two Rust closures. The first generates an initial value per group. The second
itself takes two arguments: an 'accumulator', and an element. The second closure returns the
value that the accumulator should have for the next iteration.</p>
</blockquote>
<p>A special case of <code>fold</code>, in the spirit of SQL's GROUP BY and aggregation constructs. The input
is partitioned into groups by the first field, and for each group the values in the second
field are accumulated via the closures in the arguments.</p>
<blockquote>
<p>Note: The closures have access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<p><code>group_by</code> can also be provided with one generic lifetime persistence argument, either
<code>'tick</code> or <code>'static</code>, to specify how data persists. With <code>'tick</code>, values will only be collected
within the same tick. With <code>'static</code>, values will be remembered across ticks and will be
aggregated with pairs arriving in later ticks. When not explicitly specified persistence
defaults to <code>'static</code>.</p>
<p><code>group_by</code> can also be provided with two type arguments, the key and value type. This is
required when using <code>'static</code> persistence if the compiler cannot infer the types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter([(&quot;toy&quot;, 1), (&quot;toy&quot;, 2), (&quot;shoe&quot;, 11), (&quot;shoe&quot;, 35), (&quot;haberdashery&quot;, 7)])
    -&gt; group_by(|| 0, |old: &amp;mut u32, val: u32| *old += val)
    -&gt; for_each(|(k, v)| println!(&quot;Total for group {} is {}&quot;, k, v));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Example using <code>'tick</code> persistence:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;(&amp;str, &amp;str)&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    source_stream(input_recv)
        -&gt; group_by::&lt;'tick, &amp;str, String&gt;(String::new, |old: &amp;mut _, val| {
            *old += val;
            *old += &quot;, &quot;;
        })
        -&gt; for_each(|(k, v)| println!(&quot;({:?}, {:?})&quot;, k, v));
};

input_send.send((&quot;hello&quot;, &quot;oakland&quot;)).unwrap();
input_send.send((&quot;hello&quot;, &quot;berkeley&quot;)).unwrap();
input_send.send((&quot;hello&quot;, &quot;san francisco&quot;)).unwrap();
flow.run_available();
// (&quot;hello&quot;, &quot;oakland, berkeley, san francisco, &quot;)

input_send.send((&quot;hello&quot;, &quot;palo alto&quot;)).unwrap();
flow.run_available();
// (&quot;hello&quot;, &quot;palo alto, &quot;)
<span class="boring">}
</span></code></pre></pre>
<h2 id="identity"><a class="header" href="#identity"><code>identity</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; identity() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/identity.rs" -->
<blockquote>
<p>1 input stream of type T, 1 output stream of type T</p>
</blockquote>
<p>For each item passed in, pass it out without any change.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print &quot;hello&quot; and &quot;world&quot; on separate lines (in either order)
source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; identity()
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>You can also supply a type parameter <code>identity::&lt;MyType&gt;()</code> to specify what items flow thru the
the pipeline. This can be useful for helping the compiler infer types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// Use type parameter to ensure items are `i32`s.
source_iter(0..10) -&gt; identity::&lt;i32&gt;() -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="initialize"><a class="header" href="#initialize"><code>initialize</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>initialize() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/initialize.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: None.</p>
</blockquote>
<p>Emits a single unit <code>()</code> at the start of the first tick.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>initialize() -&gt; for_each(|()| println!(&quot;This only runs one time!&quot;));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="inspect"><a class="header" href="#inspect"><code>inspect</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; inspect(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/inspect.rs" -->
<blockquote>
<p>Arguments: A single closure <code>FnMut(&amp;Item)</code>.</p>
</blockquote>
<p>An operator which allows you to &quot;inspect&quot; each element of a stream without
modifying it. The closure is called on a reference to each item. This is
mainly useful for debugging as in the example below, and it is generally an
anti-pattern to provide a closure with side effects.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter([1, 2, 3, 4]) -&gt; inspect(|&amp;x| println!(&quot;{}&quot;, x)) -&gt; null();
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="join"><a class="header" href="#join"><code>join</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 2">exactly 2</span></td><td><code>-&gt; [&lt;input_port&gt;]join() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Input port names: <code>0</code> (streaming), <code>1</code> (streaming)</p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/join.rs" -->
<blockquote>
<p>2 input streams of type &lt;(K, V1)&gt; and &lt;(K, V2)&gt;, 1 output stream of type &lt;(K, (V1, V2))&gt;</p>
</blockquote>
<p>Forms the equijoin of the tuples in the input streams by their first (key) attribute. Note that the result nests the 2nd input field (values) into a tuple in the 2nd output field.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print `(hello, (world, cleveland))`
source_iter(vec![(&quot;hello&quot;, &quot;world&quot;), (&quot;stay&quot;, &quot;gold&quot;)]) -&gt; [0]my_join;
source_iter(vec![(&quot;hello&quot;, &quot;cleveland&quot;)]) -&gt; [1]my_join;
my_join = join() -&gt; for_each(|(k, (v1, v2))| println!(&quot;({}, ({}, {}))&quot;, k, v1, v2));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>join</code> can also be provided with one or two generic lifetime persistence arguments, either
<code>'tick</code> or <code>'static</code>, to specify how join data persists. With <code>'tick</code>, pairs will only be
joined with corresponding pairs within the same tick. With <code>'static</code>, pairs will be remembered
across ticks and will be joined with pairs arriving in later ticks. When not explicitly
specified persistence defaults to `static.</p>
<p>When two persistence arguments are supplied the first maps to port <code>0</code> and the second maps to
port <code>1</code>.
When a single persistence argument is supplied, it is applied to both input ports.
When no persistence arguments are applied it defaults to <code>'static</code> for both.</p>
<p>The syntax is as follows:</p>
<pre><code class="language-hydroflow ignore">join(); // Or
join::&lt;'static&gt;();

join::&lt;'tick&gt;();

join::&lt;'static, 'tick&gt;();

join::&lt;'tick, 'static&gt;();
// etc.
</code></pre>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;(&amp;str, &amp;str)&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    source_iter([(&quot;hello&quot;, &quot;world&quot;)]) -&gt; [0]my_join;
    source_stream(input_recv) -&gt; [1]my_join;
    my_join = join::&lt;'tick&gt;() -&gt; for_each(|(k, (v1, v2))| println!(&quot;({}, ({}, {}))&quot;, k, v1, v2));
};
input_send.send((&quot;hello&quot;, &quot;oakland&quot;)).unwrap();
flow.run_tick();
input_send.send((&quot;hello&quot;, &quot;san francisco&quot;)).unwrap();
flow.run_tick();
<span class="boring">}
</span></code></pre></pre>
<p>Prints out <code>&quot;(hello, (world, oakland))&quot;</code> since <code>source_iter([(&quot;hello&quot;, &quot;world&quot;)])</code> is only
included in the first tick, then forgotten.</p>
<hr />
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;(&amp;str, &amp;str)&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    source_iter([(&quot;hello&quot;, &quot;world&quot;)]) -&gt; [0]my_join;
    source_stream(input_recv) -&gt; [1]my_join;
    my_join = join::&lt;'static&gt;() -&gt; for_each(|(k, (v1, v2))| println!(&quot;({}, ({}, {}))&quot;, k, v1, v2));
};
input_send.send((&quot;hello&quot;, &quot;oakland&quot;)).unwrap();
flow.run_tick();
input_send.send((&quot;hello&quot;, &quot;san francisco&quot;)).unwrap();
flow.run_tick();
<span class="boring">}
</span></code></pre></pre>
<p>Prints out <code>&quot;(hello, (world, oakland))&quot;</code> and <code>&quot;(hello, (world, san francisco))&quot;</code> since the
inputs are peristed across ticks.</p>
<h2 id="map"><a class="header" href="#map"><code>map</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; map(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/map.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: A Rust closure
For each item passed in, apply the closure to generate an item to emit.</p>
</blockquote>
<p>If you do not want to modify the item stream and instead only want to view
each item use the <a href="surface_ops.gen.html#inspect"><code>inspect</code></a> operator instead.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; map(|x| x.to_uppercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="merge"><a class="header" href="#merge"><code>merge</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="at least 0">at least 2</span></td><td><code>-&gt; [&lt;input_port&gt;]merge() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/merge.rs" -->
<blockquote>
<p><em>n</em> input streams of the same type, 1 output stream of the same type</p>
</blockquote>
<p>Merges an arbitrary number of input streams into a single stream. Each input sequence is a subsequence of the output, but no guarantee is given on how the inputs are interleaved.</p>
<p>Since <code>merge</code> has multiple input streams, it needs to be assigned to
a variable to reference its multiple input ports across statements.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_iter(vec![&quot;hello&quot;, &quot;world&quot;]) -&gt; my_merge;
source_iter(vec![&quot;stay&quot;, &quot;gold&quot;]) -&gt; my_merge;
source_iter(vec![&quot;don\'t&quot;, &quot;give&quot;, &quot;up&quot;]) -&gt; my_merge;
my_merge = merge() -&gt; map(|x| x.to_uppercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="next_stratum"><a class="header" href="#next_stratum"><code>next_stratum</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; next_stratum() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/next_stratum.rs" -->
<p>Delays all elements which pass through to the next stratum (in the same
tick).</p>
<h2 id="next_tick"><a class="header" href="#next_tick"><code>next_tick</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; next_tick() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/next_tick.rs" -->
<p>Delays all elements which pass through to the next tick. In short,
execution of a hydroflow graph runs as a sequence of distinct &quot;ticks&quot;.
Non-monotonic operators compute their output in terms of each tick so
execution doesn't have to block, and it is up to the user to coordinate
data between tick executions to achieve the desired result.</p>
<p>An tick may be divided into multiple <em>strata</em>, see the <a href="surface_ops.gen.html#next_stratum"><code>next_stratum()</code></a>
operator.</p>
<p>In the example below <code>next_tick()</code> is used alongside <code>difference()</code> to
ignore any items in the current tick that already appeared in the previous
tick.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Outputs 1 2 3 4 5 6 (on separate lines).
let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;usize&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    inp = source_stream(input_recv) -&gt; tee();
    diff = difference() -&gt; for_each(|x| println!(&quot;{}&quot;, x));
    inp -&gt; [pos]diff;
    inp -&gt; next_tick() -&gt; [neg]diff;
};

for x in [1, 2, 3, 4] {
    input_send.send(x).unwrap();
}
flow.run_tick();

for x in [3, 4, 5, 6] {
    input_send.send(x).unwrap();
}
flow.run_tick();
<span class="boring">}
</span></code></pre></pre>
<h2 id="null"><a class="header" href="#null"><code>null</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="at least 0 and at most 1">at least 0 and at most 1</span></td><td><code>null()</code></td><td><span title="at least 0 and at most 1">at least 0 and at most 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/null.rs" -->
<blockquote>
<p>unbounded number of input streams of any type, unbounded number of output streams of any type.</p>
</blockquote>
<p>As a source, generates nothing. As a sink, absorbs anything with no effect.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print `1, 2, 3, 4, 5, 6, a, b, c` across 9 lines
null() -&gt; for_each(|_: ()| panic!());
source_iter([1,2,3]) -&gt; map(|i| println!(&quot;{}&quot;, i)) -&gt; null();
null_src = null();
null_sink = null();
null_src[0] -&gt; for_each(|_: ()| panic!());
// note: use `for_each()` (or `inspect()`) instead of this:
source_iter([4,5,6]) -&gt; map(|i| println!(&quot;{}&quot;, i)) -&gt; [0]null_sink;
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="persist"><a class="header" href="#persist"><code>persist</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; persist() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/persist.rs" -->
<p>Stores each item as it passes through, and replays all item every tick.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// Normally `source_iter(...)` only emits once, but with `persist()` will replay the `&quot;hello&quot;`
// on every tick. This is equivalent to `repeat_iter([&quot;hello&quot;])`.
source_iter([&quot;hello&quot;])
    -&gt; persist()
    -&gt; for_each(|item| println!(&quot;{}: {}&quot;, context.current_tick(), item));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>persist()</code> can be used to introduce statefulness into stateless pipelines. For example this
join only stores data for single <code>'tick</code>. The <code>persist()</code> operator introduces statefulness
across ticks. This can be useful for optimization transformations within the hydroflow
compiler.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;(&amp;str, &amp;str)&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    repeat_iter([(&quot;hello&quot;, &quot;world&quot;)]) -&gt; [0]my_join;
    source_stream(input_recv) -&gt; persist() -&gt; [1]my_join;
    my_join = join::&lt;'tick&gt;() -&gt; for_each(|(k, (v1, v2))| println!(&quot;({}, ({}, {}))&quot;, k, v1, v2));
};
input_send.send((&quot;hello&quot;, &quot;oakland&quot;)).unwrap();
flow.run_tick();
input_send.send((&quot;hello&quot;, &quot;san francisco&quot;)).unwrap();
flow.run_tick();
// (hello, (world, oakland))
// (hello, (world, oakland))
// (hello, (world, san francisco))
<span class="boring">}
</span></code></pre></pre>
<h2 id="reduce"><a class="header" href="#reduce"><code>reduce</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; reduce(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/reduce.rs" -->
<blockquote>
<p>1 input stream, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: a closure which itself takes two arguments:
an ‘accumulator’, and an element. The closure returns the value that the accumulator should have for the next iteration.</p>
</blockquote>
<p>Akin to Rust's built-in reduce operator. Folds every element into an accumulator by applying a closure,
returning the final result.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print 120 (i.e., 1*2*3*4*5)
source_iter([1,2,3,4,5])
    -&gt; reduce(|mut accum, elem| {
        accum *= elem;
        accum
    })
    -&gt; for_each(|e| println!(&quot;{}&quot;, e));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="repeat_iter"><a class="header" href="#repeat_iter"><code>repeat_iter</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>repeat_iter(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/repeat_iter.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: An iterable Rust object.
Similar to <code>source_iter</code>, but delivers all elements from the iterable object
on every tick (where <code>source_iter</code> only delivers on the first tick).</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>    repeat_iter(vec![&quot;Hello&quot;, &quot;World&quot;])
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="sort"><a class="header" href="#sort"><code>sort</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; sort() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/sort.rs" -->
<p>Takes a stream as input and produces a sorted version of the stream as output.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print 1, 2, 3 (in order)
source_iter(vec![2, 3, 1])
    -&gt; sort()
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>sort</code> can also be provided with one generic lifetime persistence argument, either
<code>'tick</code> or <code>'static</code>, to specify how data persists. The default is <code>'tick</code>. With <code>'tick</code> only
the values will only be collected within a single tick will be sorted and emitted. With
<code>'static</code>, values will be remembered across ticks and will be repeatedly emitted each tick (in
order).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;usize&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    source_stream(input_recv)
        -&gt; sort::&lt;'static&gt;()
        -&gt; for_each(|n| println!(&quot;{}&quot;, n));
};

input_send.send(6).unwrap();
input_send.send(3).unwrap();
input_send.send(4).unwrap();
flow.run_available();
// 3, 4, 6

input_send.send(1).unwrap();
input_send.send(7).unwrap();
flow.run_available();
// 1, 3, 4, 6, 7
<span class="boring">}
</span></code></pre></pre>
<h2 id="sort_by"><a class="header" href="#sort_by"><code>sort_by</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; sort_by(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Blocking</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/sort_by.rs" -->
<p>Takes a stream as input and produces a version of the stream as output
sorted according to the key extracted by the closure.</p>
<blockquote>
<p>Note: The closure has access to the <a href="surface_flows.html#the-context-object"><code>context</code> object</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print (1, 'z'), (2, 'y'), (3, 'x') (in order)
source_iter(vec![(2, 'y'), (3, 'x'), (1, 'z')])
    -&gt; sort_by(|(k, _v)| k)
    -&gt; for_each(|x| println!(&quot;{:?}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="source_interval"><a class="header" href="#source_interval"><code>source_interval</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_interval(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_interval.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: A <a href="https://doc.rust-lang.org/stable/std/time/struct.Duration.html"><code>Duration</code></a> for this interval.</p>
</blockquote>
<p>Emits <a href="https://docs.rs/tokio/1/tokio/time/struct.Instant.html">Tokio time <code>Instant</code>s</a> on a
repeated interval. The first tick completes imediately. Missed ticks will be scheduled as soon
as possible, and the <code>Instant</code> will be the missed time, not the late time.</p>
<p>Note that this requires the hydroflow instance be run within a <a href="https://docs.rs/tokio/1/tokio/runtime/struct.Runtime.html">Tokio <code>Runtime</code></a>.
The easiest way to do this is with a <a href="https://docs.rs/tokio/1/tokio/attr.main.html"><code>#[tokio::main]</code></a>
annotation on <code>async fn main() { ... }</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Duration;

use hydroflow::hydroflow_syntax;

#[tokio::main]
async fn main() {
    let mut hf = hydroflow_syntax! {
        source_interval(Duration::from_secs(1))
            -&gt; for_each(|time| println!(&quot;This runs every second: {:?}&quot;, time));
    };

    // Will print 4 times (fencepost counting).
    tokio::time::timeout(Duration::from_secs_f32(3.5), hf.run_async())
        .await
        .expect_err(&quot;Expected time out&quot;);

    // Example output:
    // This runs every second: Instant { t: 27471.704813s }
    // This runs every second: Instant { t: 27472.704813s }
    // This runs every second: Instant { t: 27473.704813s }
    // This runs every second: Instant { t: 27474.704813s }
}
</code></pre></pre>
<h2 id="source_iter-1"><a class="header" href="#source_iter-1"><code>source_iter</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_iter(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_iter.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: An iterable Rust object.
Takes the iterable object and delivers its elements downstream
one by one.</p>
</blockquote>
<p>Note that all elements are emitted during the first tick.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>    source_iter(vec![&quot;Hello&quot;, &quot;World&quot;])
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="source_json"><a class="header" href="#source_json"><code>source_json</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_json(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_json.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: An <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a><code>&lt;</code><a href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html"><code>Path</code></a><code>&gt;</code>
for a file to read as json. This will emit the parsed value one time.</p>
</blockquote>
<p><code>source_json</code> may take one generic type argument, the type of the value to be parsed, which must implement <a href="https://docs.rs/serde/latest/serde/de/trait.Deserialize.html"><code>Deserialize</code></a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>source_json(&quot;example.json&quot;) -&gt; for_each(|json: hydroflow::serde_json::Value| println!(&quot;{:#?}&quot;, json));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="source_stdin"><a class="header" href="#source_stdin"><code>source_stdin</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_stdin() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_stdin.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: port number</p>
</blockquote>
<p><code>source_stdin</code> receives a Stream of lines from stdin
and emits each of the elements it receives downstream.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut flow = hydroflow::hydroflow_syntax! {
    source_stdin() -&gt; map(|x| x.unwrap().to_uppercase())
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
};
flow.run_async();
<span class="boring">}
</span></code></pre></pre>
<h2 id="source_stream-1"><a class="header" href="#source_stream-1"><code>source_stream</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_stream(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_stream.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: The receive end of a tokio channel</p>
</blockquote>
<p>Given a <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a>
created in Rust code, <code>source_stream</code>
is passed the receive endpoint of the channel and emits each of the
elements it receives downstream.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;&amp;str&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    source_stream(input_recv) -&gt; map(|x| x.to_uppercase())
        -&gt; for_each(|x| println!(&quot;{}&quot;, x));
};
input_send.send(&quot;Hello&quot;).unwrap();
input_send.send(&quot;World&quot;).unwrap();
flow.run_available();
<span class="boring">}
</span></code></pre></pre>
<h2 id="source_stream_serde"><a class="header" href="#source_stream_serde"><code>source_stream_serde</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 0">exactly 0</span></td><td><code>source_stream_serde(A) -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/source_stream_serde.rs" -->
<blockquote>
<p>0 input streams, 1 output stream</p>
</blockquote>
<blockquote>
<p>Arguments: <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a></p>
</blockquote>
<p>Given a <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a>
of (serialized payload, addr) pairs, deserializes the payload and emits each of the
elements it receives downstream.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn serde_in() {
    let addr = hydroflow::util::ipv4_resolve(&quot;localhost:9000&quot;.into()).unwrap();
    let (outbound, inbound, _) = hydroflow::util::bind_udp_bytes(addr).await;
    let mut flow = hydroflow::hydroflow_syntax! {
        source_stream_serde(inbound) -&gt; map(|(x, a): (String, std::net::SocketAddr)| x.to_uppercase())
            -&gt; for_each(|x| println!(&quot;{}&quot;, x));
    };
    flow.run_available();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="tee"><a class="header" href="#tee"><code>tee</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; tee()[&lt;output_port&gt;] -&gt;</code></td><td><span title="at least 0">at least 2</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/tee.rs" -->
<blockquote>
<p>1 input stream, <em>n</em> output streams</p>
</blockquote>
<p>Takes the input stream and delivers a copy of each item to each output.</p>
<blockquote>
<p>Note: Downstream operators may need explicit type annotations.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>my_tee = source_iter(vec![&quot;Hello&quot;, &quot;World&quot;]) -&gt; tee();
my_tee -&gt; map(|x: &amp;str| x.to_uppercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
my_tee -&gt; map(|x: &amp;str| x.to_lowercase())
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
my_tee -&gt; for_each(|x: &amp;str| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="unique"><a class="header" href="#unique"><code>unique</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; unique() -&gt;</code></td><td><span title="exactly 1">exactly 1</span></td><td>Streaming</td></tr>
</tbody></table>
</div><!-- GENERATED "hydroflow_lang/src/graph/ops/unique.rs" -->
<p>Takes one stream as input and filters out any duplicate occurrences. The output
contains all unique values from the input.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>// should print 1, 2, 3 (in any order)
source_iter(vec![1, 1, 2, 3, 2, 1, 3])
    -&gt; unique()
    -&gt; for_each(|x| println!(&quot;{}&quot;, x));
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>unique</code> can also be provided with one generic lifetime persistence argument, either
<code>'tick</code> or <code>'static</code>, to specify how data persists. The default is <code>'static</code>.
With <code>'tick</code>, uniqueness is only considered within the current tick, so across multiple ticks
duplicate values may be emitted.
With <code>'static</code>, values will be remembered across ticks and no duplicates will ever be emitted.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (input_send, input_recv) = hydroflow::util::unbounded_channel::&lt;usize&gt;();
let mut flow = hydroflow::hydroflow_syntax! {
    source_stream(input_recv)
        -&gt; unique::&lt;'tick&gt;()
        -&gt; for_each(|n| println!(&quot;{}&quot;, n));
};

input_send.send(3).unwrap();
input_send.send(3).unwrap();
input_send.send(4).unwrap();
input_send.send(3).unwrap();
flow.run_available();
// 3, 4

input_send.send(3).unwrap();
input_send.send(5).unwrap();
flow.run_available();
// 3, 5
// Note: 3 is emitted again.
<span class="boring">}
</span></code></pre></pre>
<h2 id="unzip"><a class="header" href="#unzip"><code>unzip</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>Inputs</th><th>Syntax</th><th>Outputs</th><th>Flow</th></tr></thead><tbody>
<tr><td><span title="exactly 1">exactly 1</span></td><td><code>-&gt; unzip()[&lt;output_port&gt;] -&gt;</code></td><td><span title="exactly 2">exactly 2</span></td><td>Streaming</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Output port names: <code>0</code>, <code>1</code></p>
</blockquote>
<!-- GENERATED "hydroflow_lang/src/graph/ops/unzip.rs" -->
<blockquote>
<p>1 input stream of pair tuples <code>(A, B)</code>, 2 output streams</p>
</blockquote>
<p>Takes the input stream of pairs and unzips each one, delivers each item to
its corresponding side.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[allow(unused_imports)] use hydroflow::{var_args, var_expr};
</span><span class="boring">#[allow(unused_imports)] use hydroflow::pusherator::Pusherator;
</span><span class="boring">let mut __hf = hydroflow::hydroflow_syntax! {
</span>my_unzip = source_iter(vec![(&quot;Hello&quot;, &quot;Foo&quot;), (&quot;World&quot;, &quot;Bar&quot;)]) -&gt; unzip();
my_unzip[0] -&gt; for_each(|x| println!(&quot;0: {}&quot;, x)); // Hello World
my_unzip[1] -&gt; for_each(|x| println!(&quot;1: {}&quot;, x)); // Foo Bar
<span class="boring">};
</span><span class="boring">for _ in 0..100 {
</span><span class="boring">    if !__hf.run_tick() {
</span><span class="boring">        // No work done.
</span><span class="boring">        break;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-and-lifetimes"><a class="header" href="#state-and-lifetimes">State and Lifetimes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-hydro-ecosystem"><a class="header" href="#the-hydro-ecosystem">The Hydro Ecosystem</a></h1>
<p>The Hydro Project is an evolving stack of libraries and languages for distributed programming.
A rough picture of the envisioned Hydro stack is below:</p>
<p><img src="./img/hydro_stack.png" alt="Hydro Stack" /></p>
<p>The core of the Hydro stack is shown in in the grey box; components that have not been implemented are in orange. </p>
<p>Working up from the bottom:</p>
<ul>
<li>
<p><a href="https://github.com/hydro-project/hydroplane">Hydroplane</a> is a service for launching and monitoring Hydroflow transducers. It works both on local developer machines with Docker, and in cloud services like AWS EKS. Over time we expect to add autoscaling features to Hydroplane, to allow users to configure the cluster to grow and shrink based on the monitored behavior and a pluggable policy.</p>
</li>
<li>
<p><a href="https://github.com/hydro-project/hydroplane">Hydroflow</a> is the subject of this book; a library for defining individual transducers in a distributed system. It uses the Rust compiler to generate binaries for deployment.</p>
</li>
<li>
<p><em>Hydrolysis</em> is a compiler we envision translating from Hydrologic to Hydroflow.</p>
</li>
<li>
<p><em>Hydrologic</em> is a high-level domain-specific language that we envision for distributed programming. Unlike Hydroflow, we expect Hydrologic to abstract away many notions of distributed computing. In particular, Hydrologic will be insensitive to the specific deployment of the code—the partitioning of functionality and data across transducers, the number of replicas of each transducer, etc. Instead, programmers will provide specifications for desired properties like the number of failures to tolerate, the consistency desired at a given endpoint, the latency of a given endpoint, etc. The Hydrolysis compiler will then generate Hydroflow transducers that can be deployed by Hydroplane to meet those specifications.</p>
</li>
<li>
<p><a href="https://github.com/metalift/metalift">Metalift</a> is a framework for &quot;lifting&quot; code from one language to a (typically higher-level) language. We envision that Metalift will be used to translate from one of many distributed programming models/languages into our common Internal Representation, Hydrologic.</p>
</li>
</ul>
<p>The Hydro stack is inspired by previous language stacks including <a href="https://llvm.org">LLVM</a> and <a href="https://halide-lang.org">Halide</a>, which similarly expose multiple human-programmable Internal Representation langauges.</p>
<p>An early paper on the Hydro vision appeared in CIDR 2021, under the title <a href="https://www.cidrdb.org/cidr2021/papers/cidr2021_paper16.pdf">New Directions in Cloud Programming</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>Hydroflow is different from other distributed systems infrastructure, so you probably have questions, like:
What is Hydroflow? How does it work? What is special about it, and what are the key concepts to understand?</p>
<p>This chapter covers those basic questions. We start simple describing Hydroflow, and build up to an understanding of 
what makes Hydroflow uniquely powerful.</p>
<p>But in case you want a preview of the Hydroflow goodies, here are the main themes:</p>
<ol>
<li><strong>Distributed Correctness</strong>: Hydroflow's type system can prevent distributed system bugs at compile time. (One example: will your code
produce the same results if you deploy on a single machine or replicate on a distributed cluster of machines?)</li>
<li><strong>Local Efficiency</strong>: Hydroflow compiles your dataflow programs into efficient, low-latency, single-threaded executables.</li>
</ol>
<p>Taken together, Hydroflow provides a high-efficiency substrate on which to build powerful languages for distributed computing.</p>
<blockquote>
<p>Hydroflow's type system checks are not yet implemented, but they are coming soon!</p>
</blockquote>
<h2 id="hydroflow-a-runtime-library-and-a-dsl-in-rust"><a class="header" href="#hydroflow-a-runtime-library-and-a-dsl-in-rust">Hydroflow: A Runtime Library and a DSL in Rust</a></h2>
<p>Setting fanfare aside, what <em>is</em> Hydroflow?</p>
<p>Hydroflow is a library that can be used in any Rust program. It includes two main components:</p>
<ol>
<li>A runtime library that executes low-latency, reactive dataflow programs written in Rust. (The <em>core API</em>.)</li>
<li>A domain-specific language (DSL) for specifying dataflow programs. (The Hydroflow <em>surface syntax</em>.) </li>
</ol>
<p>Hydroflow's surface syntax must be embedded in a Rust program; the Rust compiler takes that Hydroflow syntax and 
compiles it into an efficient binary executable. </p>
<blockquote>
<p>We call a running Hydroflow binary a <em>transducer</em>.</p>
</blockquote>
<p>In typical usage, a developer writes a transducer as a single-threaded Rust program that is mostly composed of 
Hydroflow surface syntax. Each transducer is typically responsible for a single 
&quot;node&quot; (a machine, or a core) in a distributed system composed of many such transducers,
which send and receive flows of data to each other.</p>
<blockquote>
<p>Hydroflow itself does not generate distributed code. It is a library for specifying the transducers (individual nodes) that 
participate in a distributed system. </p>
<p>In the <a href="https://hydro.run">Hydro Project</a>, higher-level languages are being built on top of Hydroflow to generate 
distributed code in the form of multiple transducers. 
Meanwhile, you can use Hydroflow to write your own distributed code, by writing individual transducers that work together, 
and deploying them manually or with a tool like <a href="https://github.com/hydro-project/hydroplane">Hydroplane</a>. See the <a href="./ecosystem.html">Hydro Ecosystem</a> for more on this.</p>
</blockquote>
<h3 id="so-how-might-a-human-write-distributed-systems-with-hydroflow"><a class="header" href="#so-how-might-a-human-write-distributed-systems-with-hydroflow">So how might a human write distributed systems with Hydroflow?</a></h3>
<p>As an illustration of how you can work at the Hydroflow layer, consider the 
<a href="./example_8_chat_server.html">Chat Server example</a>. If you run that binary
with the command-line argument <code>--role server</code> it will start a single transducer that is responsible for a chat server: receiving
membership requests and messages from clients, and forwarding messages from individual clients to all other clients.
If you run that binary with the argument <code>--role client</code> it will start a transducer that is responsible for a chat client, which 
forwards chat messages from stdin to the server, and prints out messages sent by the server. As a distributed system, the chat 
service would typically consist of many client transducers and a single server transducer.</p>
<p>Note that this is an example of an extremely simple distributed system in a &quot;star&quot; or &quot;hub-and spokes&quot; topology: the multiple client transducers are completely independent of each other, and each talks only with the central server transducer. </p>
<div align="center">
<pre class="mermaid">%%{init: {'theme':'neutral'}}%%
graph TD;
    Client1---S((Server));
    Client2---S;
    Client3---S;
    S---Client4;
    S---Client5;
    S---Client6;
</pre>
</div>
<p>If we wanted something more interesting, we could consider deploying a cluster of multiple server transducers, say for fault tolerance or geo-distribution, perhaps like this: </p>
<div align="center">
<pre class="mermaid">%%{init: {'theme':'neutral'}}%%
graph LR;
    subgraph servers[Server Cluster]
        S1((Server1))---S2((Server2))---S3((Server3))---S1;
    end
    Client1---S1;
    Client2---S1;
    Client3---S2;
    S2---Client4;
    S3---Client5;
    S3---Client6;
</pre>
</div>
<p>We'd need to change the server code to get servers sharing their state in a correct and reliable manner. But that's a topic for another section <strong>TODO</strong>; for now, let's stay focused on the basics. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-life-and-times-of-a-hydroflow-transducer"><a class="header" href="#the-life-and-times-of-a-hydroflow-transducer">The Life and Times of a Hydroflow Transducer</a></h1>
<p>Time is a fundamental concept in many distributed systems. Hydroflow's model of time is very simple, but 
also powerful enough to serve as a building block for more complex models of time.</p>
<p>Like most reactive services, we can envision a Hydroflow transducer running as an unbounded loop that is managed 
by the runtime library. Each iteration of the transducer's loop is called a <em>tick</em>. Associated with the transducer is 
a <em>clock</em> value (accessible via the <code>.current_tick()</code> method), which tells you how many ticks were executed 
by this transducer prior to the current tick. Each transducer produces totally ordered, sequentially increasing clock values, 
which you can think of as the &quot;local logical time&quot; at the transducer.</p>
<p>The transducer's main loop works as follows:</p>
<ol>
<li>Given events and messages buffered from the operating system, ingest a batch of data items and deliver them to the appropriate <code>source_xxx</code> operators in the Hydroflow spec.</li>
<li>Run the Hydroflow spec. If the spec has cycles, continue executing it until it reaches a &quot;fixpoint&quot; on the current batch; i.e. it no longer produces any new data anywhere in the flow. Along the way, any data that appears in an outbound channel is streamed to the appropriate destination.</li>
<li>Once the spec reaches fixpoint and messages have all been sent, advance the local clock and then start the next tick.</li>
</ol>
<p>The transducer's main loop is shown in the following diagram:</p>
<pre class="mermaid">%%{init: {'theme':'neutral'}}%%
flowchart LR
    subgraph external[External]
        network&gt;&quot;messages\n&amp; events&quot;\nfa:fa-telegram]--&gt;buffer[[buffer]]
    end
    subgraph transducer[Transducer Loop]
         buffer--&gt;ingest&gt;ingest a batch\nof data]--&gt;loop(((run Hydroflow\nspec to fixpoint\nfa:fa-cog)))--&gt;stream[stream out\nmsgs &amp; events\nfa:fa-telegram]--&gt;clock((advance\nclock\nfa:fa-clock-o))-- new tick! --&gt;ingest
    end
    style stream fill:#0fa,stroke:#aaa,stroke-width:2px,stroke-dasharray: 5 5
    style loop fill:#0fa
    style clock fill:#f00
    style ingest fill:#f00
    linkStyle 5 stroke:red,stroke-width:4px,color:red;
</pre>
<p>In sum, an individual transducer advances sequentially through logical time; in each tick of its clock it ingests a batch of data from its inbound channels, executes the Hydroflow spec, and sends any outbound data to its outbound channels.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="streaming-blocking-and-stratification"><a class="header" href="#streaming-blocking-and-stratification">Streaming, Blocking and Stratification</a></h1>
<p>Many Hydroflow operators (e.g. <code>map</code>, <code>filter</code> and <code>join</code>) work in a streaming fashion. Streaming operators process data as it arrives, generating outputs in the midst of processing inputs. If you restrict yourself to operators that work in this streaming fashion, then your transducer may start sending data across the network mid-tick, even while it is still consuming the data in the input batch.</p>
<p>But some operators are blocking, and must wait for all their input data to arrive before they can produce any output data. For example, a <code>sort</code> operator must wait for all its input data to arrive before it can produce a single output value. After all, the lowest value may be the last to arrive!</p>
<h2 id="examples-of-blocking-operators"><a class="header" href="#examples-of-blocking-operators">Examples of Blocking Operators</a></h2>
<p>The discussion above should raise questions in your mind. What do we mean by &quot;all the input data&quot; in a long-running service? We don't want to wait until the end of time—this is one reason we break time up into discrete &quot;ticks&quot; at each transducer. So when we say that a blocking operator waits for &quot;all the input data&quot;, we mean &quot;all the input data in the current tick&quot;.</p>
<p>Consider the simple statement below, which receives data from a network source each tick, sorts that tick's worth of data, and prints it to stdout:</p>
<pre><code class="language-rust ignore">source_stream(inbound) -&gt; sort() -&gt; for_each(|x| println!(&quot;{:?}&quot;, x));
</code></pre>
<p>The runtime determines arbitrarily what batch of data is taken from the channel and fed into the <code>source_stream_serde</code> operator for this tick. The sort operator will need to know that the <code>source_stream_serde</code> operator has no more data to send this tick, so that it can sort the data that got buffered and then send the sorted data to the <code>for_each</code> operator, which prints it to stdout. To do this, the runtime provides a mechanism for the <code>source_stream_serde</code> operator to buffer its output and notify the <code>sort</code> operator that it has no more data to send. This is called a <em>handoff</em>.</p>
<p>You can see the mermaid graph for the statement above just below this paragraph. Notice the two outer rectangles and the handoff between them. Each rectangle is a subflow that is
assigned a <em>stratum</em> number. (&quot;Stratum&quot; is latin for &quot;layer&quot;; the plural of &quot;stratum&quot; is &quot;strata&quot;.) </p>
<pre class="mermaid">%%{init: {'theme': 'base', 'themeVariables': {'clusterBkg':'#ddd'}}}%%
flowchart LR
classDef pullClass fill:#02f,color:#fff,stroke:#000
classDef pushClass fill:#ff0,stroke:#000
linkStyle default stroke:#aaa,stroke-width:4px,color:red,font-size:1.5em;
subgraph &quot;sg_1v1 stratum 0&quot;
    1v1[\&quot;(1v1) &lt;tt&gt;source_stream(edges_recv)&lt;/tt&gt;&quot;/]:::pullClass
end
subgraph &quot;sg_2v1 stratum 1&quot;
    2v1[/&quot;(2v1) &lt;tt&gt;sort()&lt;/tt&gt;&quot;\]:::pushClass
    3v1[/&quot;(3v1) &lt;tt&gt;for_each(| x | println! (&amp;quot;{:?}&amp;quot;, x))&lt;/tt&gt;&quot;\]:::pushClass
    2v1---&gt;3v1
end
1v1---&gt;4v1
4v1[&quot;(4v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
4v1===o2v1
</pre>
<p>At compile time, the Hydroflow spec is <em>stratified</em>: partitioned into subflows, where each subflow is assigned a stratum number. Subsequently at runtime, each tick executes the strata one-by-one in ascending order of stratum number. In the example above, the <code>source_stream</code> operator is in stratum 0, and the <code>sort</code> and <code>for_each</code> operators are in stratum 1. The runtime executes the <code>source_stream</code> operator first, buffering output in the Handoff. The <code>sort</code> operator will not receive any data until the <code>source_stream</code> operator has finished executing. When stratum 0 is complete, the subflow in stratum 1 is scheduled and executes the <code>sort</code> and <code>for_each</code> operators to complete the tick. </p>
<p>Let's look back at the <a href="./surface_ops.gen.html#difference"><code>difference</code></a> operator as used in the <a href="./example_6_unreachability.html">Graph Unreachability example</a>.</p>
<pre class="mermaid">flowchart TD
classDef pullClass fill:#02f,color:#fff,stroke:#000
classDef pushClass fill:#ff0,stroke:#000
linkStyle default stroke:#aaa,stroke-width:4px,color:red,font-size:1.5em;
subgraph &quot;sg_4v1 stratum 1&quot;
    11v1[\&quot;(11v1) &lt;tt&gt;difference()&lt;/tt&gt;&quot;/]:::pullClass
    14v1[/&quot;(14v1) &lt;tt&gt;for_each(| v | println! (&amp;quot;unreached_vertices vertex: {}&amp;quot;, v))&lt;/tt&gt;&quot;\]:::pushClass
    11v1---&gt;14v1
end
17v1[&quot;(17v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
17v1--pos---&gt;11v1
18v1[&quot;(18v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
18v1==neg===o11v1
</pre>
<p>The <code>difference</code> operators is one with inputs of two different types. It is supposed to output all the items from its <code>pos</code> input that do not appear in its <code>neg</code> input. To achieve that, the <code>neg</code> input must be blocking, but the <code>pos</code> input can stream. Blocking on the <code>neg</code> input ensures that if the operator streams an output from the <code>pos</code> input, it will never need to retract that output.</p>
<p>Given these examples, we can refine our diagram of the Hydroflow transducer loop to account for stratified execution within each tick:</p>
<pre class="mermaid">%%{init: {'theme':'neutral'}}%%
flowchart LR
    subgraph external[External]
        network&gt;&quot;messages\n&amp; events&quot;\nfa:fa-telegram]--&gt;buffer[[buffer]]
    end
    subgraph transducer[Transducer Loop]
         buffer--&gt;ingest&gt;&quot;ingest a batch\nof data&quot;]--&gt;loop(((&quot;for each stratum in\n[0..max(strata)]\nrun stratum to fixpoint\nfa:fa-cog&quot;)))--&gt;stream[stream out\nmsgs &amp; events\nfa:fa-telegram]--&gt;clock((advance\nclock\nfa:fa-clock-o))-- new tick! --&gt;ingest
    end
    style stream fill:#0fa,stroke:#aaa,stroke-width:2px,stroke-dasharray: 5 5
    style loop fill:#0fa
    style clock fill:#f00
    style ingest fill:#f00
    linkStyle 5 stroke:red,stroke-width:4px,color:red;
</pre>
<h2 id="technical-details"><a class="header" href="#technical-details">Technical Details</a></h2>
<p>The concept of stratification is taken directly from stratified negation in the <a href="https://en.wikipedia.org/wiki/Datalog">Datalog</a> language. Hydroflow identifies a stratum boundary at any blocking input to an operator, where classical Datalog only stratifies its negation operator.</p>
<p>The Hydroflow compiler performs stratification via static analysis of the Hydroflow spec. The analysis is based on the following rules:</p>
<ul>
<li>A Handoff is interposed in front of any blocking input to an operator (as documented in the <a href="./surface_ops.gen.html">operator definitions</a>.</li>
<li>The flow is partitioned at the Handoffs into subflows called &quot;strata&quot;.</li>
<li>The resulting graph of strata and Handoffs is tested to ensure that it's acyclic. (Cycles through blocking operators are forbidden as they not have well-defined behavior—note that the blocking operators in a cycle would deadlock waiting for each other.)</li>
</ul>
<p>Given the acyclicity test, any legal Hydroflow program consists of a directed acyclic graph (DAG) of strata and handoffs. The strata are numbered in ascending order by assigning stratum number 0 to the &quot;leaves&quot; of the DAG (strata with no upstream operators), and then ensuring that each stratum is assigned a number that is one larger than any of its upstream strata.</p>
<p>As a Hydroflow operator executes, it is running on a particular transducer, in a particular tick, in a particular stratum. </p>
<h3 id="determining-whether-an-operator-should-block-monotonicity"><a class="header" href="#determining-whether-an-operator-should-block-monotonicity">Determining whether an operator should block: Monotonicity</a></h3>
<p>Why are some inputs to operators streaming, and others blocking? Intuitively, the blocking operators must hold off on emitting outputs early because they may receive another input that would change their output. For example, a <code>difference</code> operator on integers cannot emit the number 4 from its <code>pos</code> input if it may subsequently receive a 4  within the same tick on the <code>neg</code> input. More generally, it cannot output anything until it has received all the <code>neg</code> input data. </p>
<p>By contrast, streaming operators like <code>filter</code> have the property that they can always emit an output, <em>regardless of what other data they will receive later in the tick</em>. </p>
<p>Mathematically, we can think of a dataflow operator as a function <em>f(in) → out</em> from one batch of data to another. We call a function <a href="https://en.wikipedia.org/wiki/Monotonic_function#In_order_theory">monotone</a> if its output is a growing function of its input. That is, <em>f</em> is classified as a monotone function if <em>f(B) ⊆ f(C)</em> whenever <em>B ⊆ C</em>.</p>
<p>By contrast, consider the output of a blocking operator like <code>difference</code>. The output of <code>difference</code> is a function of both its inputs, but it is <em>non-monotone</em> with respect to its <code>neg</code> input. That is, it is <em>not</em> the case that <em>(A — B) ⊆ (A — C)</em> whenever <em>B ⊆ C</em>. </p>
<p>Hydroflow is designed to use the monotonicity property to determine whether an operator should block. If an operator is monotone with respect to an input, that input is streaming. If an operator is non-monotone, it is blocking.</p>
<p>Monotonicity turns out to be particularly important for distributed systems. In particular, if all your transducers are fully monotone across ticks, then they can run in parallel without any coordination—they will always stream correct prefixes of the final outputs, and eventually will deliver the complete output. This is the positive direction of the <a href="https://cacm.acm.org/magazines/2020/9/246941-keeping-calm/fulltext">CALM Theorem</a>.</p>
<blockquote>
<p>In future versions of Hydroflow, the type system will represent monotonicity explicitly and reason about it automatically.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distributed-time"><a class="header" href="#distributed-time">Distributed Time</a></h1>
<p>Hydroflow does not embed a particular notion of distributed time, but instead provides primitives for 
you to implement one of many possible distributed time models. If you're a distributed systems aficionado, you might
be interested to read this chapter to learn about how Hydroflow's time model compares to classical distributed time models.</p>
<h2 id="lamport-time"><a class="header" href="#lamport-time">Lamport Time</a></h2>
<p>Lamport's paper on <a href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf">Time, Clocks, and the Ordering of Events in a Distributed System</a> provides a classical definition of time in a distributed system. In that paper, each single-threaded <em>process</em> has a sequential clock (a so-called <a href="https://en.wikipedia.org/wiki/Lamport_timestamp">Lamport Clock</a>). The clock in a process advances by one unit of time for each <em>event</em> that the process observes. Between events, the clock is frozen and the process does local computation.</p>
<p>In addition, to maintain Lamport Clocks, each process stamps its outbound messages with the current clock value, and begins each &quot;tick&quot; by <em>advancing</em> its local clock to the larger of </p>
<ul>
<li>its current clock value and </li>
<li>the largest clock value of any message it received. </li>
</ul>
<p>The way that Lamport clocks jump ahead provides a desirable property: the timestamps provide a reasonable notion of what events <em>happen-before</em> other events in a distributed system.
Lamport timestamps track not only the order of events on a single node, they also ensure that the timestamps on events reflect distributed ordering. Suppose that node <code>source</code> wants to send a message to node <code>dest</code>, and node source has current clock value <em>T_source</em>. The events that precede that message on node <code>source</code> have smaller timestamps. In addition, consider an event at node <code>dest</code> that follows the receipt of that message. That event must have a timestamp greater than <em>T_source</em> by Lamport's advancing rule above. Hence all the events on node <code>source</code> that preceded the sending of the message have lower timestamps than the events on node <code>dest</code> following the receipt of the message. This is Lamport's distributed &quot;happens-before&quot; relation, and the Lamport clock capture that relation.</p>
<h2 id="hydroflow-time"><a class="header" href="#hydroflow-time">Hydroflow Time</a></h2>
<p>As a built-in primitive, Hydroflow defines time only for a single transducer, as a sequence of consecutive ticks without any gaps. </p>
<p>Thus the main difference between Hydroflow events and Lamport events are:</p>
<ol>
<li><strong>Batched Events</strong>: Hydroflow treats the ingestion of a batch of multiple inbound events as a single tick. <em>TODO: is it possible to limit batch size to 1?</em> </li>
<li><strong>Fixpoints between Events</strong>: Hydroflow <em>requires</em> a fixpoint computation to complete between ticks.</li>
<li><strong>Consecutive Ticks</strong>: the built-in clock primitive in Hydroflow always advances sequentially and cannot skip a tick like the Lamport clock does.</li>
</ol>
<h2 id="implementing-distributed-time-in-hydroflow"><a class="header" href="#implementing-distributed-time-in-hydroflow">Implementing Distributed Time in Hydroflow</a></h2>
<p>Although Lamport clocks are not built into Hydroflow, it is straightforward to implement them in Hydroflow. Alternatively, one can implement more sophisticated distributed clocks like <a href="https://en.wikipedia.org/wiki/Vector_clock">vector clocks</a> in Hydroflow instead. By leaving this decision to the user, Hydroflow can be used in a variety of distributed time models.</p>
<p><em>TODO: add example of implementing Lamport clocks?</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>Hydroflow graphs are divided into two layers: the outer <em>scheduled layer</em> and
inner <em>compiled layer</em>.</p>
<p>In the mermaid diagrams generated for Hydroflow, the scheduler is responsible for the outermost gray boxes 
(the <em>subgraphs</em>)
and handoffs, while the insides of the gray boxes are compiled via the compiled layer. As a reminder,
here is the graph from the
<a href="./example_5_reachability.html">reachability</a> chapter, which we will use a running example:</p>
<pre class="mermaid">%%{init: {'theme': 'base', 'themeVariables': {'clusterBkg':'#ddd'}}}%%
flowchart TD
classDef pullClass fill:#02f,color:#fff,stroke:#000
classDef pushClass fill:#ff0,stroke:#000
linkStyle default stroke:#aaa,stroke-width:4px,color:red,font-size:1.5em;
subgraph &quot;sg_1v1 stratum 0&quot;
    1v1[\&quot;(1v1) &lt;tt&gt;source_iter(vec! [0])&lt;/tt&gt;&quot;/]:::pullClass
    2v1[\&quot;(2v1) &lt;tt&gt;source_stream(edges_recv)&lt;/tt&gt;&quot;/]:::pullClass
    3v1[\&quot;(3v1) &lt;tt&gt;merge()&lt;/tt&gt;&quot;/]:::pullClass
    7v1[\&quot;(7v1) &lt;tt&gt;map(| v | (v, ()))&lt;/tt&gt;&quot;/]:::pullClass
    4v1[\&quot;(4v1) &lt;tt&gt;join()&lt;/tt&gt;&quot;/]:::pullClass
    5v1[/&quot;(5v1) &lt;tt&gt;flat_map(| (src, ((), dst)) | [src, dst])&lt;/tt&gt;&quot;\]:::pushClass
    6v1[/&quot;(6v1) &lt;tt&gt;tee()&lt;/tt&gt;&quot;\]:::pushClass
    10v1[&quot;(10v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
    10v1--1---&gt;3v1
    1v1--0---&gt;3v1
    2v1--1---&gt;4v1
    3v1---&gt;7v1
    7v1--0---&gt;4v1
    4v1---&gt;5v1
    5v1---&gt;6v1
    6v1--0---&gt;10v1
end
subgraph &quot;sg_2v1 stratum 1&quot;
    8v1[/&quot;(8v1) &lt;tt&gt;unique()&lt;/tt&gt;&quot;\]:::pushClass
    9v1[/&quot;(9v1) &lt;tt&gt;for_each(| x | println! (&amp;quot;Reached: {}&amp;quot;, x))&lt;/tt&gt;&quot;\]:::pushClass
    8v1---&gt;9v1
end
6v1--1---&gt;11v1
11v1[&quot;(11v1) &lt;tt&gt;handoff&lt;/tt&gt;&quot;]:::otherClass
11v1===o8v1
</pre>
<p>The <a href="https://hydro-project.github.io/hydroflow/design_docs/2021-10_architecture_design_doc.html">Hydroflow Architecture Design Doc</a>
contains a more detailed explanation of this section. Note that some aspects of
the design doc are not implemented (e.g. early yielding) or may become out of
date as time passes.</p>
<h2 id="scheduled-layer"><a class="header" href="#scheduled-layer">Scheduled Layer</a></h2>
<p>The scheduled layer is dynamic: it stores a list of operators (or &quot;subgraphs&quot;)
as well as buffers (&quot;handoffs&quot;) between them. The scheduled layer chooses how
to schedule the operators (naturally), and when each operator runs it pulls
from its input handoffs and pushes to its output handoffs. This setup is
extremely flexible: operators can have any number of input or output handoffs
so we can easily represent any graph topology. However this flexibility comes
at a performance cost due to the overhead of scheduling, buffering, and lack
of inter-operator compiler optimization.</p>
<p>The <em>compiled layer</em> helps avoids the costs of the scheduled layer. We can
combine several operators into a <em>subgraph</em> which are compiled and optimized as
a single scheduled subgraph. The scheduled layer then runs the entire subgraph
as if it was one operator with many inputs and outputs. Note the layering here:
the compiled layer does not replace the scheduled layer but instead exists
within it.</p>
<h2 id="compiled-layer"><a class="header" href="#compiled-layer">Compiled Layer</a></h2>
<p>Rust already has a built-in API similar to dataflow: <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code>s</a>.
When they work well, they work really well and tend to be as fast as for loops.
However, they are limited in the flow graphs they can represent. Each operator
in a <code>Iterator</code> takes ownership of, and <em>pulls</em> from, the previous operator.
Taking two iterators as <em>inputs</em> and merging them together (e.g. with
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>.chain(...)</code></a>
or <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.zip"><code>.zip(...)</code></a>)
is natural and performant as we can <em>pull</em> from both. However if we want an
iterator to split into multiple <em>outputs</em> then things become tricky. <a href="https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.tee"><code>Itertools::tee()</code></a>
does just this by cloning each incoming item into two output buffers, but this
requires allocation and could cause unbounded buffer growth if the outputs are
not read from at relatively even rates.</p>
<p>However, if instead iterators were <em>push</em>-based, where each operator owns one
or more <em>output</em> operators, then teeing is very easy, just clone each element
and push to (i.e. run) both outputs. So that's what we did, created push-based
iterators to allow fast teeing or splitting in the compiled layer.</p>
<p>Pull-based iterators can be connected to push-based iterators at a single &quot;pivot&quot;
point. Together, this pull-to-push setup dictates the shape compiled subgraphs
can take. Informally, this is like the roots and leaves of a tree. Water flows
from the roots (the pull inputs), eventually all join together in the trunk
(the pull-to-push pivot), the split up into multiple outputs in the leaves.
We refer to this structure as an <em>in-out tree</em>.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/oaklandish_logo.jpg" alt="The Oaklandish Logo depicting the stylized roots, trunk, and branches of a tree." /></td></tr>
<tr><td style="text-align: center">The Oaklandish Logo.</td></tr>
</tbody></table>
</div>
<p>In the reachability example above, the pivot is the <code>flat_map()</code> operator: it pulls from the join that feeds it, and pushes to the tee that follows it. In essence that <code>flat_map()</code> serves as the main thread of the compiled component.</p>
<p>See <a href="./in-out_trees.html">Subgraph In-Out Trees</a> for more, including how to
convert a graph into in-out trees.</p>
<h2 id="surface-syntax-and-apis"><a class="header" href="#surface-syntax-and-apis">Surface Syntax and APIs</a></h2>
<p>Hydroflow's <em>Surface Syntax</em> hides
the distinction between these two layers. It offers a natural <code>Iterator</code>-like chaining syntax for building 
graphs that get parsed and compiled into a scheduled graph of one or more compiled subgraphs. Please see the <a href="./surface_syntax.html">Surface Syntax</a> docs for more information.</p>
<p>Alternatively, the <em>Core API</em> allows you to interact with handoffs directly at a low
level. It doesn't provide any notion of chainable operators. You can use Rust <code>Iterator</code>s
or any other arbitrary Rust code to implement the operators.</p>
<p>The Core API lives in <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/index.html"><code>hydroflow::scheduled</code></a>,
mainly in methods on the <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html"><code>Hydroflow</code> struct</a>.  Compiled push-based iterators live in <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/compiled/index.html"><code>hydroflow::compiled</code></a>. We intend users to use the Surface Syntax as it is much more friendly, but as
Hydroflow is in active development some operators might not be available in
the Surface Syntax, in which case the Core API can be used instead. If you find
yourself in this sitation be sure to <a href="https://github.com/hydro-project/hydroflow/issues/new">submit an issue</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scheduling"><a class="header" href="#scheduling">Scheduling</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handoffs"><a class="header" href="#handoffs">Handoffs</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking"><a class="header" href="#networking">Networking</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subgraph-in-out-trees"><a class="header" href="#subgraph-in-out-trees">Subgraph In-Out Trees</a></h1>
<p>Formally, we define an in-out-tree is the union of an
<em>in-tree</em> (<a href="https://en.wikipedia.org/wiki/Arborescence_%28graph_theory%29#cite_ref-KorteVygen2012b_17-0"><em>anti-arborescence</em></a>)
with an <em>out-tree</em> (<a href="https://en.wikipedia.org/wiki/Arborescence_%28graph_theory%29"><em>arborescence</em></a>)
where both trees share the same <em>root</em> node.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/in-out_tree.png" alt="A graph showing multiple nodes on the left all eventually feeding into a central pivot node, then continuing to multiple output nodes." /></td></tr>
<tr><td style="text-align: center">An <em>in-out tree</em> graph. Data flows from the green <em>pull</em> operators on the left, through the yellow pivot, and to the red <em>push</em> operators on the right.</td></tr>
</tbody></table>
</div>
<p>In this graph representation, each node corresponds to an operator, and the
edges direct the flow of data between operators.</p>
<h2 id="converting-graph"><a class="header" href="#converting-graph">Converting Graph</a></h2>
<p>Any graph can be partitioned into in-out trees. Any non-trivial graph will have many possible
partitionings to choose from; a useful heuristic is to partition the graph
into as few subgraphs as possible, in order to minimize scheduling overheads.</p>
<p>Most graphs are pretty simple and can be partitioned with a bit of eye-balling.
To do this systematically, we can use a simple
coloring algorithm.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/in-out_example.png" alt="A random-looking directed graph with 8 nodes." /></td></tr>
<tr><td style="text-align: center">An example directed graph.</td></tr>
</tbody></table>
</div>
<p>To identify the in-out trees in an arbitrary directed graph, first identify any
nodes which have multiple inputs and outputs and mark these as pull-to-push
<em>pivots</em> (yellow in the example). Mark any nodes with multiple inputs (and a
single output) as <em>pull</em> (green) and any nodes with multiple outputs as <em>push</em>
(red).</p>
<p>In the example:</p>
<div class="table-wrapper"><table><thead><tr><th>Pivots (yellow)</th><th>Pulls (green)</th><th>Pushes (red)</th></tr></thead><tbody>
<tr><td>1, 4</td><td>2</td><td>3, 7</td></tr>
</tbody></table>
</div>
<p>Finally any one-in-one-out nodes should be marked the same as their neighbors
(either green pull or red push). If we have green pull -&gt; red push that becomes
a yellow pivot. And if red push -&gt; green pull that becomes a blue handoff node,
and this is a division between subgraphs. Note that a subgraph can have a
handoff with itself; this forms a loop.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/in-out_partition.png" alt="The graph above converted and partitioned into two in-out trees." /></td></tr>
<tr><td style="text-align: center">The graph above converted and partitioned into two in-out trees. One is outlined in yellow and the other in red. For the corresponding Hydroflow graph, green nodes are <em>pull</em>, red nodes are <em>push</em>, yellow are <em>pivots</em>, and blue are <em>handoffs</em>.</td></tr>
</tbody></table>
</div>
<p>In the example partitioning above, some nodes have been split into multiple and
labelled with suffixes to make the pivots and handoffs more explicit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo"><a class="header" href="#todo">TODO</a></h1>
<h2 id="concepts-1"><a class="header" href="#concepts-1">Concepts</a></h2>
<ul>
<li>p1 (Mingwei) Hydroflow and Rust: how do they go together?
<ul>
<li>State, control, scoping</li>
</ul>
</li>
<li>p1 State over time
<ul>
<li>lifetimes</li>
<li>explicit deletion</li>
</ul>
</li>
<li>p3 Coordination tricks?
<ul>
<li>End-of-stream to Distributed EOS?</li>
</ul>
</li>
</ul>
<h2 id="docs"><a class="header" href="#docs">Docs</a></h2>
<ul>
<li>p1 <code>hydroflow</code> struct and its methods</li>
<li>p2 Review the ops docs</li>
</ul>
<h2 id="operators-not-discussed"><a class="header" href="#operators-not-discussed">Operators not discussed</a></h2>
<pre><code>- dest_sink
- identity
- repeat_iter
- unzip
- p1 *fold* -- add to chapter on [state](state.md)
- p1 *reduce* -- add to chapter on [state](state.md)
- p1 *group_by* -- add to chapter on [state](state.md)
- p3 *sort_by* -- add to chapter on [state](state.md)
- p2 *next_stratum* -- add to chapter on [time](time.md)
- p2 *next_tick* -- add to chapter on [time](time.md)
- p2 *inspect* -- add to chapter on [debugging](debugging.md)
- p2 *null* -- add to chapter on [debugging](debugging.md)
</code></pre>
<h2 id="how-tos-and-examples"><a class="header" href="#how-tos-and-examples">How-Tos and Examples</a></h2>
<ul>
<li>p1 Lamport clocks</li>
<li>p2 Vector clocks</li>
<li>p2 A partitioned Service</li>
<li>p2 A replicated Service</li>
<li>p2 Interfacing with external data</li>
<li>p2 Interfacing with external services</li>
<li>p1 Illustrate <code>'static</code> and <code>'tick</code> lifetimes (KVS)</li>
<li>p3 Illustrate the <code>next_stratum</code> operator for atomicity (eg Bloom's upsert <code>&lt;+-</code> operator)</li>
<li>p3 Illustrate ordered streams (need <code>zip</code> operator ... what's the example?)</li>
<li>p3 Actor model implementation (Borrow an Akka or Ray Actors example?)</li>
<li>p3 Futures emulation? (Borrow a Ray example)</li>
<li>p2 Illustrate external storage source and sink (e.g. for WAL of KVS)</li>
</ul>
<h2 id="odds-and-ends-taken-out-of-other-chapters"><a class="header" href="#odds-and-ends-taken-out-of-other-chapters">Odds and ends taken out of other chapters</a></h2>
<ul>
<li>
<p><strong>Document the methods on the <code>hydroflow</code> struct</strong> -- especially the run methods.</p>
<ul>
<li>The <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run_tick"><code>run_tick()</code></a>, <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run_stratum"><code>run_stratum()</code></a>, <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run"><code>run()</code></a>, and <a href="https://hydro-project.github.io/hydroflow/doc/hydroflow/scheduled/graph/struct.Hydroflow.html#method.run_async"><code>run_async()</code></a> methods provide other ways to control the graph execution.</li>
<li>Also <code>run_available()</code> <code>next_stratum()</code> and <code>recv_events</code> are important</li>
</ul>
</li>
<li>
<p><strong>Make sure <code>src/examples/echoserver</code> is the same as the template project</strong> -- or better, find a way to do that via github actions or a github submodule</p>
</li>
</ul>
<h2 id="whats-covered-in-examples"><a class="header" href="#whats-covered-in-examples">What's covered in examples</a></h2>
<ul>
<li>
<p>Concepts covered</p>
<ul>
<li>cargo generate for templating</li>
<li>Hydroflow program specs embedded in Rust</li>
<li>Tokio Channels and how to use them in Hydroflow
<ul>
<li>Network sources and sinks (source_stream)</li>
<li>Built-in serde (source_stream_serde, dest_sink_serde)</li>
</ul>
</li>
<li>Hydroflow syntax: operators, -&gt;, variables, indexing multi-input/output operators</li>
<li>running Hydroflow via <code>run_available</code> and <code>run_async</code></li>
<li>Recursion via cyclic dataflow</li>
<li>Fixpoints and Strata</li>
<li>Template structure: clap, message types</li>
<li>source_stdin</li>
<li>Messages and <code>demux</code></li>
<li>broadcast pattern</li>
<li>gated buffer pattern</li>
<li>bootstrapping pipelines</li>
</ul>
</li>
<li>
<p>Operators covered</p>
<ul>
<li>cross_join</li>
<li>demux</li>
<li>dest_sink_serde</li>
<li>difference</li>
<li>filter</li>
<li>filter_map</li>
<li>flatten</li>
<li>flat_map</li>
<li>for_each</li>
<li>join</li>
<li>map</li>
<li>merge</li>
<li>source_iter</li>
<li>source_stdin</li>
<li>source_stream</li>
<li>source_stream_serde</li>
<li>tee</li>
<li>unique</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h4 id="q-how-is-hydroflow-different-from-dataflow-systems-like-spark-flink-or-mapreduce"><a class="header" href="#q-how-is-hydroflow-different-from-dataflow-systems-like-spark-flink-or-mapreduce">Q: How is Hydroflow different from dataflow systems like Spark, Flink, or MapReduce?</a></h4>
<p><strong>A:</strong> Hydroflow is designed as a substrate for building a wide range of distributed systems; traditional software dataflow systems
like the ones mentioned are targeted more narrowly at large-scale data processing. As such, Hydroflow differs from these systems in several ways:</p>
<p>First, Hydroflow is a lower-level abstraction than the systems mentioned. Hydroflow adopts a dataflow abstraction for specifying a transducer
running on a <em>single core</em>; one implementes a distributed system out of multiple Hydroflow transducers.  By contrast, Spark, Flink and MapReduce are 
distributed systems, which make specific choices for implementing issues like scheduling, fault tolerance, and so on.</p>
<p>Second, the systems mentioned above were designed specifically for distributed data processing tasks. 
By contrast, Hydroflow is designed as a compiler target for many possible language models. Distributed
dataflow systems like those mentioned above are one possible higher-level model one could build with Hydroflow, 
but there are many others.</p>
<p>Third, Hydroflow is a <em>reactive</em> dataflow engine, optimized for low-latency handling of 
asynchronous events and messages in a long-lived service. For example, one can build 
low-level protocol handlers in Hydroflow for implementing distributed protocols
like Paxos or Two-Phase Commit with low latency.</p>
<h4 id="q-what-model-of-parallelism-does-hydroflow-use-spmd-mpmd-actors-mpi"><a class="header" href="#q-what-model-of-parallelism-does-hydroflow-use-spmd-mpmd-actors-mpi">Q: What model of parallelism does Hydroflow use? SPMD? MPMD? Actors? MPI?</a></h4>
<p><strong>A:</strong> As a substrate for building individual nodes in a distributed systems, Hydroflow does not make any 
assumptions about the model of parallelism used. One can construct a distributed system out of Hydroflow 
transducers that use any model of parallelism, including 
<a href="https://en.wikipedia.org/wiki/Flynn%27s_taxonomy#Single_program,_multiple_data_streams_(SPMD)">SPMD</a>, 
<a href="https://en.wikipedia.org/wiki/Flynn%27s_taxonomy#Multiple_programs,_multiple_data_streams_(MPMD)">MPMD</a>, 
<a href="https://en.wikipedia.org/wiki/Actor_model">Actors</a> or 
<a href="https://en.wikipedia.org/wiki/Collective_operation">MPI Collective Operations</a>. 
Hydroflow provides abstractions for implementing individual transducers to handle inputs, computing, and emitting outputs in
a general-purpose manner.</p>
<p>That said, it is common practice to deploy many instance of the same Hydroflow transducer; most distributed systems built in Hydroflow
therefore have some form of SPMD parallelism. (This is true of most distributed systems in general.)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
